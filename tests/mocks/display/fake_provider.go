// Code generated by counterfeiter. DO NOT EDIT.
package display

import (
	"sync"

	"github.com/inference-gateway/cli/internal/display"
)

type FakeProvider struct {
	GetControllerStub        func() (display.DisplayController, error)
	getControllerMutex       sync.RWMutex
	getControllerArgsForCall []struct {
	}
	getControllerReturns struct {
		result1 display.DisplayController
		result2 error
	}
	getControllerReturnsOnCall map[int]struct {
		result1 display.DisplayController
		result2 error
	}
	GetDisplayInfoStub        func() display.DisplayInfo
	getDisplayInfoMutex       sync.RWMutex
	getDisplayInfoArgsForCall []struct {
	}
	getDisplayInfoReturns struct {
		result1 display.DisplayInfo
	}
	getDisplayInfoReturnsOnCall map[int]struct {
		result1 display.DisplayInfo
	}
	IsAvailableStub        func() bool
	isAvailableMutex       sync.RWMutex
	isAvailableArgsForCall []struct {
	}
	isAvailableReturns struct {
		result1 bool
	}
	isAvailableReturnsOnCall map[int]struct {
		result1 bool
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeProvider) GetController() (display.DisplayController, error) {
	fake.getControllerMutex.Lock()
	ret, specificReturn := fake.getControllerReturnsOnCall[len(fake.getControllerArgsForCall)]
	fake.getControllerArgsForCall = append(fake.getControllerArgsForCall, struct {
	}{})
	stub := fake.GetControllerStub
	fakeReturns := fake.getControllerReturns
	fake.recordInvocation("GetController", []interface{}{})
	fake.getControllerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeProvider) GetControllerCallCount() int {
	fake.getControllerMutex.RLock()
	defer fake.getControllerMutex.RUnlock()
	return len(fake.getControllerArgsForCall)
}

func (fake *FakeProvider) GetControllerCalls(stub func() (display.DisplayController, error)) {
	fake.getControllerMutex.Lock()
	defer fake.getControllerMutex.Unlock()
	fake.GetControllerStub = stub
}

func (fake *FakeProvider) GetControllerReturns(result1 display.DisplayController, result2 error) {
	fake.getControllerMutex.Lock()
	defer fake.getControllerMutex.Unlock()
	fake.GetControllerStub = nil
	fake.getControllerReturns = struct {
		result1 display.DisplayController
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) GetControllerReturnsOnCall(i int, result1 display.DisplayController, result2 error) {
	fake.getControllerMutex.Lock()
	defer fake.getControllerMutex.Unlock()
	fake.GetControllerStub = nil
	if fake.getControllerReturnsOnCall == nil {
		fake.getControllerReturnsOnCall = make(map[int]struct {
			result1 display.DisplayController
			result2 error
		})
	}
	fake.getControllerReturnsOnCall[i] = struct {
		result1 display.DisplayController
		result2 error
	}{result1, result2}
}

func (fake *FakeProvider) GetDisplayInfo() display.DisplayInfo {
	fake.getDisplayInfoMutex.Lock()
	ret, specificReturn := fake.getDisplayInfoReturnsOnCall[len(fake.getDisplayInfoArgsForCall)]
	fake.getDisplayInfoArgsForCall = append(fake.getDisplayInfoArgsForCall, struct {
	}{})
	stub := fake.GetDisplayInfoStub
	fakeReturns := fake.getDisplayInfoReturns
	fake.recordInvocation("GetDisplayInfo", []interface{}{})
	fake.getDisplayInfoMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeProvider) GetDisplayInfoCallCount() int {
	fake.getDisplayInfoMutex.RLock()
	defer fake.getDisplayInfoMutex.RUnlock()
	return len(fake.getDisplayInfoArgsForCall)
}

func (fake *FakeProvider) GetDisplayInfoCalls(stub func() display.DisplayInfo) {
	fake.getDisplayInfoMutex.Lock()
	defer fake.getDisplayInfoMutex.Unlock()
	fake.GetDisplayInfoStub = stub
}

func (fake *FakeProvider) GetDisplayInfoReturns(result1 display.DisplayInfo) {
	fake.getDisplayInfoMutex.Lock()
	defer fake.getDisplayInfoMutex.Unlock()
	fake.GetDisplayInfoStub = nil
	fake.getDisplayInfoReturns = struct {
		result1 display.DisplayInfo
	}{result1}
}

func (fake *FakeProvider) GetDisplayInfoReturnsOnCall(i int, result1 display.DisplayInfo) {
	fake.getDisplayInfoMutex.Lock()
	defer fake.getDisplayInfoMutex.Unlock()
	fake.GetDisplayInfoStub = nil
	if fake.getDisplayInfoReturnsOnCall == nil {
		fake.getDisplayInfoReturnsOnCall = make(map[int]struct {
			result1 display.DisplayInfo
		})
	}
	fake.getDisplayInfoReturnsOnCall[i] = struct {
		result1 display.DisplayInfo
	}{result1}
}

func (fake *FakeProvider) IsAvailable() bool {
	fake.isAvailableMutex.Lock()
	ret, specificReturn := fake.isAvailableReturnsOnCall[len(fake.isAvailableArgsForCall)]
	fake.isAvailableArgsForCall = append(fake.isAvailableArgsForCall, struct {
	}{})
	stub := fake.IsAvailableStub
	fakeReturns := fake.isAvailableReturns
	fake.recordInvocation("IsAvailable", []interface{}{})
	fake.isAvailableMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeProvider) IsAvailableCallCount() int {
	fake.isAvailableMutex.RLock()
	defer fake.isAvailableMutex.RUnlock()
	return len(fake.isAvailableArgsForCall)
}

func (fake *FakeProvider) IsAvailableCalls(stub func() bool) {
	fake.isAvailableMutex.Lock()
	defer fake.isAvailableMutex.Unlock()
	fake.IsAvailableStub = stub
}

func (fake *FakeProvider) IsAvailableReturns(result1 bool) {
	fake.isAvailableMutex.Lock()
	defer fake.isAvailableMutex.Unlock()
	fake.IsAvailableStub = nil
	fake.isAvailableReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeProvider) IsAvailableReturnsOnCall(i int, result1 bool) {
	fake.isAvailableMutex.Lock()
	defer fake.isAvailableMutex.Unlock()
	fake.IsAvailableStub = nil
	if fake.isAvailableReturnsOnCall == nil {
		fake.isAvailableReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isAvailableReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeProvider) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeProvider) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ display.Provider = new(FakeProvider)
