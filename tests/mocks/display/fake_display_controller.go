// Code generated by counterfeiter. DO NOT EDIT.
package display

import (
	"context"
	"image"
	"sync"

	"github.com/inference-gateway/cli/internal/display"
)

type FakeDisplayController struct {
	CaptureScreenStub        func(context.Context, *display.Region) (image.Image, error)
	captureScreenMutex       sync.RWMutex
	captureScreenArgsForCall []struct {
		arg1 context.Context
		arg2 *display.Region
	}
	captureScreenReturns struct {
		result1 image.Image
		result2 error
	}
	captureScreenReturnsOnCall map[int]struct {
		result1 image.Image
		result2 error
	}
	CaptureScreenBytesStub        func(context.Context, *display.Region) ([]byte, error)
	captureScreenBytesMutex       sync.RWMutex
	captureScreenBytesArgsForCall []struct {
		arg1 context.Context
		arg2 *display.Region
	}
	captureScreenBytesReturns struct {
		result1 []byte
		result2 error
	}
	captureScreenBytesReturnsOnCall map[int]struct {
		result1 []byte
		result2 error
	}
	ClickMouseStub        func(context.Context, display.MouseButton, int) error
	clickMouseMutex       sync.RWMutex
	clickMouseArgsForCall []struct {
		arg1 context.Context
		arg2 display.MouseButton
		arg3 int
	}
	clickMouseReturns struct {
		result1 error
	}
	clickMouseReturnsOnCall map[int]struct {
		result1 error
	}
	CloseStub        func() error
	closeMutex       sync.RWMutex
	closeArgsForCall []struct {
	}
	closeReturns struct {
		result1 error
	}
	closeReturnsOnCall map[int]struct {
		result1 error
	}
	GetCursorPositionStub        func(context.Context) (int, int, error)
	getCursorPositionMutex       sync.RWMutex
	getCursorPositionArgsForCall []struct {
		arg1 context.Context
	}
	getCursorPositionReturns struct {
		result1 int
		result2 int
		result3 error
	}
	getCursorPositionReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 error
	}
	GetScreenDimensionsStub        func(context.Context) (int, int, error)
	getScreenDimensionsMutex       sync.RWMutex
	getScreenDimensionsArgsForCall []struct {
		arg1 context.Context
	}
	getScreenDimensionsReturns struct {
		result1 int
		result2 int
		result3 error
	}
	getScreenDimensionsReturnsOnCall map[int]struct {
		result1 int
		result2 int
		result3 error
	}
	MoveMouseStub        func(context.Context, int, int) error
	moveMouseMutex       sync.RWMutex
	moveMouseArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}
	moveMouseReturns struct {
		result1 error
	}
	moveMouseReturnsOnCall map[int]struct {
		result1 error
	}
	ScrollMouseStub        func(context.Context, int, string) error
	scrollMouseMutex       sync.RWMutex
	scrollMouseArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 string
	}
	scrollMouseReturns struct {
		result1 error
	}
	scrollMouseReturnsOnCall map[int]struct {
		result1 error
	}
	SendKeyComboStub        func(context.Context, string) error
	sendKeyComboMutex       sync.RWMutex
	sendKeyComboArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	sendKeyComboReturns struct {
		result1 error
	}
	sendKeyComboReturnsOnCall map[int]struct {
		result1 error
	}
	TypeTextStub        func(context.Context, string, int) error
	typeTextMutex       sync.RWMutex
	typeTextArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}
	typeTextReturns struct {
		result1 error
	}
	typeTextReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeDisplayController) CaptureScreen(arg1 context.Context, arg2 *display.Region) (image.Image, error) {
	fake.captureScreenMutex.Lock()
	ret, specificReturn := fake.captureScreenReturnsOnCall[len(fake.captureScreenArgsForCall)]
	fake.captureScreenArgsForCall = append(fake.captureScreenArgsForCall, struct {
		arg1 context.Context
		arg2 *display.Region
	}{arg1, arg2})
	stub := fake.CaptureScreenStub
	fakeReturns := fake.captureScreenReturns
	fake.recordInvocation("CaptureScreen", []interface{}{arg1, arg2})
	fake.captureScreenMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDisplayController) CaptureScreenCallCount() int {
	fake.captureScreenMutex.RLock()
	defer fake.captureScreenMutex.RUnlock()
	return len(fake.captureScreenArgsForCall)
}

func (fake *FakeDisplayController) CaptureScreenCalls(stub func(context.Context, *display.Region) (image.Image, error)) {
	fake.captureScreenMutex.Lock()
	defer fake.captureScreenMutex.Unlock()
	fake.CaptureScreenStub = stub
}

func (fake *FakeDisplayController) CaptureScreenArgsForCall(i int) (context.Context, *display.Region) {
	fake.captureScreenMutex.RLock()
	defer fake.captureScreenMutex.RUnlock()
	argsForCall := fake.captureScreenArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDisplayController) CaptureScreenReturns(result1 image.Image, result2 error) {
	fake.captureScreenMutex.Lock()
	defer fake.captureScreenMutex.Unlock()
	fake.CaptureScreenStub = nil
	fake.captureScreenReturns = struct {
		result1 image.Image
		result2 error
	}{result1, result2}
}

func (fake *FakeDisplayController) CaptureScreenReturnsOnCall(i int, result1 image.Image, result2 error) {
	fake.captureScreenMutex.Lock()
	defer fake.captureScreenMutex.Unlock()
	fake.CaptureScreenStub = nil
	if fake.captureScreenReturnsOnCall == nil {
		fake.captureScreenReturnsOnCall = make(map[int]struct {
			result1 image.Image
			result2 error
		})
	}
	fake.captureScreenReturnsOnCall[i] = struct {
		result1 image.Image
		result2 error
	}{result1, result2}
}

func (fake *FakeDisplayController) CaptureScreenBytes(arg1 context.Context, arg2 *display.Region) ([]byte, error) {
	fake.captureScreenBytesMutex.Lock()
	ret, specificReturn := fake.captureScreenBytesReturnsOnCall[len(fake.captureScreenBytesArgsForCall)]
	fake.captureScreenBytesArgsForCall = append(fake.captureScreenBytesArgsForCall, struct {
		arg1 context.Context
		arg2 *display.Region
	}{arg1, arg2})
	stub := fake.CaptureScreenBytesStub
	fakeReturns := fake.captureScreenBytesReturns
	fake.recordInvocation("CaptureScreenBytes", []interface{}{arg1, arg2})
	fake.captureScreenBytesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeDisplayController) CaptureScreenBytesCallCount() int {
	fake.captureScreenBytesMutex.RLock()
	defer fake.captureScreenBytesMutex.RUnlock()
	return len(fake.captureScreenBytesArgsForCall)
}

func (fake *FakeDisplayController) CaptureScreenBytesCalls(stub func(context.Context, *display.Region) ([]byte, error)) {
	fake.captureScreenBytesMutex.Lock()
	defer fake.captureScreenBytesMutex.Unlock()
	fake.CaptureScreenBytesStub = stub
}

func (fake *FakeDisplayController) CaptureScreenBytesArgsForCall(i int) (context.Context, *display.Region) {
	fake.captureScreenBytesMutex.RLock()
	defer fake.captureScreenBytesMutex.RUnlock()
	argsForCall := fake.captureScreenBytesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDisplayController) CaptureScreenBytesReturns(result1 []byte, result2 error) {
	fake.captureScreenBytesMutex.Lock()
	defer fake.captureScreenBytesMutex.Unlock()
	fake.CaptureScreenBytesStub = nil
	fake.captureScreenBytesReturns = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeDisplayController) CaptureScreenBytesReturnsOnCall(i int, result1 []byte, result2 error) {
	fake.captureScreenBytesMutex.Lock()
	defer fake.captureScreenBytesMutex.Unlock()
	fake.CaptureScreenBytesStub = nil
	if fake.captureScreenBytesReturnsOnCall == nil {
		fake.captureScreenBytesReturnsOnCall = make(map[int]struct {
			result1 []byte
			result2 error
		})
	}
	fake.captureScreenBytesReturnsOnCall[i] = struct {
		result1 []byte
		result2 error
	}{result1, result2}
}

func (fake *FakeDisplayController) ClickMouse(arg1 context.Context, arg2 display.MouseButton, arg3 int) error {
	fake.clickMouseMutex.Lock()
	ret, specificReturn := fake.clickMouseReturnsOnCall[len(fake.clickMouseArgsForCall)]
	fake.clickMouseArgsForCall = append(fake.clickMouseArgsForCall, struct {
		arg1 context.Context
		arg2 display.MouseButton
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ClickMouseStub
	fakeReturns := fake.clickMouseReturns
	fake.recordInvocation("ClickMouse", []interface{}{arg1, arg2, arg3})
	fake.clickMouseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDisplayController) ClickMouseCallCount() int {
	fake.clickMouseMutex.RLock()
	defer fake.clickMouseMutex.RUnlock()
	return len(fake.clickMouseArgsForCall)
}

func (fake *FakeDisplayController) ClickMouseCalls(stub func(context.Context, display.MouseButton, int) error) {
	fake.clickMouseMutex.Lock()
	defer fake.clickMouseMutex.Unlock()
	fake.ClickMouseStub = stub
}

func (fake *FakeDisplayController) ClickMouseArgsForCall(i int) (context.Context, display.MouseButton, int) {
	fake.clickMouseMutex.RLock()
	defer fake.clickMouseMutex.RUnlock()
	argsForCall := fake.clickMouseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDisplayController) ClickMouseReturns(result1 error) {
	fake.clickMouseMutex.Lock()
	defer fake.clickMouseMutex.Unlock()
	fake.ClickMouseStub = nil
	fake.clickMouseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDisplayController) ClickMouseReturnsOnCall(i int, result1 error) {
	fake.clickMouseMutex.Lock()
	defer fake.clickMouseMutex.Unlock()
	fake.ClickMouseStub = nil
	if fake.clickMouseReturnsOnCall == nil {
		fake.clickMouseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.clickMouseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDisplayController) Close() error {
	fake.closeMutex.Lock()
	ret, specificReturn := fake.closeReturnsOnCall[len(fake.closeArgsForCall)]
	fake.closeArgsForCall = append(fake.closeArgsForCall, struct {
	}{})
	stub := fake.CloseStub
	fakeReturns := fake.closeReturns
	fake.recordInvocation("Close", []interface{}{})
	fake.closeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDisplayController) CloseCallCount() int {
	fake.closeMutex.RLock()
	defer fake.closeMutex.RUnlock()
	return len(fake.closeArgsForCall)
}

func (fake *FakeDisplayController) CloseCalls(stub func() error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = stub
}

func (fake *FakeDisplayController) CloseReturns(result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	fake.closeReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDisplayController) CloseReturnsOnCall(i int, result1 error) {
	fake.closeMutex.Lock()
	defer fake.closeMutex.Unlock()
	fake.CloseStub = nil
	if fake.closeReturnsOnCall == nil {
		fake.closeReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.closeReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDisplayController) GetCursorPosition(arg1 context.Context) (int, int, error) {
	fake.getCursorPositionMutex.Lock()
	ret, specificReturn := fake.getCursorPositionReturnsOnCall[len(fake.getCursorPositionArgsForCall)]
	fake.getCursorPositionArgsForCall = append(fake.getCursorPositionArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetCursorPositionStub
	fakeReturns := fake.getCursorPositionReturns
	fake.recordInvocation("GetCursorPosition", []interface{}{arg1})
	fake.getCursorPositionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDisplayController) GetCursorPositionCallCount() int {
	fake.getCursorPositionMutex.RLock()
	defer fake.getCursorPositionMutex.RUnlock()
	return len(fake.getCursorPositionArgsForCall)
}

func (fake *FakeDisplayController) GetCursorPositionCalls(stub func(context.Context) (int, int, error)) {
	fake.getCursorPositionMutex.Lock()
	defer fake.getCursorPositionMutex.Unlock()
	fake.GetCursorPositionStub = stub
}

func (fake *FakeDisplayController) GetCursorPositionArgsForCall(i int) context.Context {
	fake.getCursorPositionMutex.RLock()
	defer fake.getCursorPositionMutex.RUnlock()
	argsForCall := fake.getCursorPositionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDisplayController) GetCursorPositionReturns(result1 int, result2 int, result3 error) {
	fake.getCursorPositionMutex.Lock()
	defer fake.getCursorPositionMutex.Unlock()
	fake.GetCursorPositionStub = nil
	fake.getCursorPositionReturns = struct {
		result1 int
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDisplayController) GetCursorPositionReturnsOnCall(i int, result1 int, result2 int, result3 error) {
	fake.getCursorPositionMutex.Lock()
	defer fake.getCursorPositionMutex.Unlock()
	fake.GetCursorPositionStub = nil
	if fake.getCursorPositionReturnsOnCall == nil {
		fake.getCursorPositionReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 error
		})
	}
	fake.getCursorPositionReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDisplayController) GetScreenDimensions(arg1 context.Context) (int, int, error) {
	fake.getScreenDimensionsMutex.Lock()
	ret, specificReturn := fake.getScreenDimensionsReturnsOnCall[len(fake.getScreenDimensionsArgsForCall)]
	fake.getScreenDimensionsArgsForCall = append(fake.getScreenDimensionsArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.GetScreenDimensionsStub
	fakeReturns := fake.getScreenDimensionsReturns
	fake.recordInvocation("GetScreenDimensions", []interface{}{arg1})
	fake.getScreenDimensionsMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2, ret.result3
	}
	return fakeReturns.result1, fakeReturns.result2, fakeReturns.result3
}

func (fake *FakeDisplayController) GetScreenDimensionsCallCount() int {
	fake.getScreenDimensionsMutex.RLock()
	defer fake.getScreenDimensionsMutex.RUnlock()
	return len(fake.getScreenDimensionsArgsForCall)
}

func (fake *FakeDisplayController) GetScreenDimensionsCalls(stub func(context.Context) (int, int, error)) {
	fake.getScreenDimensionsMutex.Lock()
	defer fake.getScreenDimensionsMutex.Unlock()
	fake.GetScreenDimensionsStub = stub
}

func (fake *FakeDisplayController) GetScreenDimensionsArgsForCall(i int) context.Context {
	fake.getScreenDimensionsMutex.RLock()
	defer fake.getScreenDimensionsMutex.RUnlock()
	argsForCall := fake.getScreenDimensionsArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeDisplayController) GetScreenDimensionsReturns(result1 int, result2 int, result3 error) {
	fake.getScreenDimensionsMutex.Lock()
	defer fake.getScreenDimensionsMutex.Unlock()
	fake.GetScreenDimensionsStub = nil
	fake.getScreenDimensionsReturns = struct {
		result1 int
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDisplayController) GetScreenDimensionsReturnsOnCall(i int, result1 int, result2 int, result3 error) {
	fake.getScreenDimensionsMutex.Lock()
	defer fake.getScreenDimensionsMutex.Unlock()
	fake.GetScreenDimensionsStub = nil
	if fake.getScreenDimensionsReturnsOnCall == nil {
		fake.getScreenDimensionsReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
			result3 error
		})
	}
	fake.getScreenDimensionsReturnsOnCall[i] = struct {
		result1 int
		result2 int
		result3 error
	}{result1, result2, result3}
}

func (fake *FakeDisplayController) MoveMouse(arg1 context.Context, arg2 int, arg3 int) error {
	fake.moveMouseMutex.Lock()
	ret, specificReturn := fake.moveMouseReturnsOnCall[len(fake.moveMouseArgsForCall)]
	fake.moveMouseArgsForCall = append(fake.moveMouseArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.MoveMouseStub
	fakeReturns := fake.moveMouseReturns
	fake.recordInvocation("MoveMouse", []interface{}{arg1, arg2, arg3})
	fake.moveMouseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDisplayController) MoveMouseCallCount() int {
	fake.moveMouseMutex.RLock()
	defer fake.moveMouseMutex.RUnlock()
	return len(fake.moveMouseArgsForCall)
}

func (fake *FakeDisplayController) MoveMouseCalls(stub func(context.Context, int, int) error) {
	fake.moveMouseMutex.Lock()
	defer fake.moveMouseMutex.Unlock()
	fake.MoveMouseStub = stub
}

func (fake *FakeDisplayController) MoveMouseArgsForCall(i int) (context.Context, int, int) {
	fake.moveMouseMutex.RLock()
	defer fake.moveMouseMutex.RUnlock()
	argsForCall := fake.moveMouseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDisplayController) MoveMouseReturns(result1 error) {
	fake.moveMouseMutex.Lock()
	defer fake.moveMouseMutex.Unlock()
	fake.MoveMouseStub = nil
	fake.moveMouseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDisplayController) MoveMouseReturnsOnCall(i int, result1 error) {
	fake.moveMouseMutex.Lock()
	defer fake.moveMouseMutex.Unlock()
	fake.MoveMouseStub = nil
	if fake.moveMouseReturnsOnCall == nil {
		fake.moveMouseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.moveMouseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDisplayController) ScrollMouse(arg1 context.Context, arg2 int, arg3 string) error {
	fake.scrollMouseMutex.Lock()
	ret, specificReturn := fake.scrollMouseReturnsOnCall[len(fake.scrollMouseArgsForCall)]
	fake.scrollMouseArgsForCall = append(fake.scrollMouseArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.ScrollMouseStub
	fakeReturns := fake.scrollMouseReturns
	fake.recordInvocation("ScrollMouse", []interface{}{arg1, arg2, arg3})
	fake.scrollMouseMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDisplayController) ScrollMouseCallCount() int {
	fake.scrollMouseMutex.RLock()
	defer fake.scrollMouseMutex.RUnlock()
	return len(fake.scrollMouseArgsForCall)
}

func (fake *FakeDisplayController) ScrollMouseCalls(stub func(context.Context, int, string) error) {
	fake.scrollMouseMutex.Lock()
	defer fake.scrollMouseMutex.Unlock()
	fake.ScrollMouseStub = stub
}

func (fake *FakeDisplayController) ScrollMouseArgsForCall(i int) (context.Context, int, string) {
	fake.scrollMouseMutex.RLock()
	defer fake.scrollMouseMutex.RUnlock()
	argsForCall := fake.scrollMouseArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDisplayController) ScrollMouseReturns(result1 error) {
	fake.scrollMouseMutex.Lock()
	defer fake.scrollMouseMutex.Unlock()
	fake.ScrollMouseStub = nil
	fake.scrollMouseReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDisplayController) ScrollMouseReturnsOnCall(i int, result1 error) {
	fake.scrollMouseMutex.Lock()
	defer fake.scrollMouseMutex.Unlock()
	fake.ScrollMouseStub = nil
	if fake.scrollMouseReturnsOnCall == nil {
		fake.scrollMouseReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.scrollMouseReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDisplayController) SendKeyCombo(arg1 context.Context, arg2 string) error {
	fake.sendKeyComboMutex.Lock()
	ret, specificReturn := fake.sendKeyComboReturnsOnCall[len(fake.sendKeyComboArgsForCall)]
	fake.sendKeyComboArgsForCall = append(fake.sendKeyComboArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.SendKeyComboStub
	fakeReturns := fake.sendKeyComboReturns
	fake.recordInvocation("SendKeyCombo", []interface{}{arg1, arg2})
	fake.sendKeyComboMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDisplayController) SendKeyComboCallCount() int {
	fake.sendKeyComboMutex.RLock()
	defer fake.sendKeyComboMutex.RUnlock()
	return len(fake.sendKeyComboArgsForCall)
}

func (fake *FakeDisplayController) SendKeyComboCalls(stub func(context.Context, string) error) {
	fake.sendKeyComboMutex.Lock()
	defer fake.sendKeyComboMutex.Unlock()
	fake.SendKeyComboStub = stub
}

func (fake *FakeDisplayController) SendKeyComboArgsForCall(i int) (context.Context, string) {
	fake.sendKeyComboMutex.RLock()
	defer fake.sendKeyComboMutex.RUnlock()
	argsForCall := fake.sendKeyComboArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeDisplayController) SendKeyComboReturns(result1 error) {
	fake.sendKeyComboMutex.Lock()
	defer fake.sendKeyComboMutex.Unlock()
	fake.SendKeyComboStub = nil
	fake.sendKeyComboReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDisplayController) SendKeyComboReturnsOnCall(i int, result1 error) {
	fake.sendKeyComboMutex.Lock()
	defer fake.sendKeyComboMutex.Unlock()
	fake.SendKeyComboStub = nil
	if fake.sendKeyComboReturnsOnCall == nil {
		fake.sendKeyComboReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.sendKeyComboReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDisplayController) TypeText(arg1 context.Context, arg2 string, arg3 int) error {
	fake.typeTextMutex.Lock()
	ret, specificReturn := fake.typeTextReturnsOnCall[len(fake.typeTextArgsForCall)]
	fake.typeTextArgsForCall = append(fake.typeTextArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.TypeTextStub
	fakeReturns := fake.typeTextReturns
	fake.recordInvocation("TypeText", []interface{}{arg1, arg2, arg3})
	fake.typeTextMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeDisplayController) TypeTextCallCount() int {
	fake.typeTextMutex.RLock()
	defer fake.typeTextMutex.RUnlock()
	return len(fake.typeTextArgsForCall)
}

func (fake *FakeDisplayController) TypeTextCalls(stub func(context.Context, string, int) error) {
	fake.typeTextMutex.Lock()
	defer fake.typeTextMutex.Unlock()
	fake.TypeTextStub = stub
}

func (fake *FakeDisplayController) TypeTextArgsForCall(i int) (context.Context, string, int) {
	fake.typeTextMutex.RLock()
	defer fake.typeTextMutex.RUnlock()
	argsForCall := fake.typeTextArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeDisplayController) TypeTextReturns(result1 error) {
	fake.typeTextMutex.Lock()
	defer fake.typeTextMutex.Unlock()
	fake.TypeTextStub = nil
	fake.typeTextReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeDisplayController) TypeTextReturnsOnCall(i int, result1 error) {
	fake.typeTextMutex.Lock()
	defer fake.typeTextMutex.Unlock()
	fake.TypeTextStub = nil
	if fake.typeTextReturnsOnCall == nil {
		fake.typeTextReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.typeTextReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeDisplayController) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeDisplayController) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ display.DisplayController = new(FakeDisplayController)
