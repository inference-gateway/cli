// Code generated by counterfeiter. DO NOT EDIT.
package generated

import (
	"sync"

	"github.com/inference-gateway/cli/internal/domain"
	"github.com/inference-gateway/sdk"
)

type FakeStateManager struct {
	AddQueuedMessageStub        func(domain.Message, string)
	addQueuedMessageMutex       sync.RWMutex
	addQueuedMessageArgsForCall []struct {
		arg1 domain.Message
		arg2 string
	}
	AddTaskToInMemoryRetentionStub        func(domain.RetainedTaskInfo)
	addTaskToInMemoryRetentionMutex       sync.RWMutex
	addTaskToInMemoryRetentionArgsForCall []struct {
		arg1 domain.RetainedTaskInfo
	}
	CancelBackgroundTaskStub        func(string, domain.ToolService) error
	cancelBackgroundTaskMutex       sync.RWMutex
	cancelBackgroundTaskArgsForCall []struct {
		arg1 string
		arg2 domain.ToolService
	}
	cancelBackgroundTaskReturns struct {
		result1 error
	}
	cancelBackgroundTaskReturnsOnCall map[int]struct {
		result1 error
	}
	ClearFileSelectionStateStub        func()
	clearFileSelectionStateMutex       sync.RWMutex
	clearFileSelectionStateArgsForCall []struct {
	}
	ClearQueuedMessagesStub        func()
	clearQueuedMessagesMutex       sync.RWMutex
	clearQueuedMessagesArgsForCall []struct {
	}
	ClearRetainedTasksStub        func()
	clearRetainedTasksMutex       sync.RWMutex
	clearRetainedTasksArgsForCall []struct {
	}
	CompleteCurrentToolStub        func(*domain.ToolExecutionResult) error
	completeCurrentToolMutex       sync.RWMutex
	completeCurrentToolArgsForCall []struct {
		arg1 *domain.ToolExecutionResult
	}
	completeCurrentToolReturns struct {
		result1 error
	}
	completeCurrentToolReturnsOnCall map[int]struct {
		result1 error
	}
	EndChatSessionStub        func()
	endChatSessionMutex       sync.RWMutex
	endChatSessionArgsForCall []struct {
	}
	EndToolExecutionStub        func()
	endToolExecutionMutex       sync.RWMutex
	endToolExecutionArgsForCall []struct {
	}
	FailCurrentToolStub        func(*domain.ToolExecutionResult) error
	failCurrentToolMutex       sync.RWMutex
	failCurrentToolArgsForCall []struct {
		arg1 *domain.ToolExecutionResult
	}
	failCurrentToolReturns struct {
		result1 error
	}
	failCurrentToolReturnsOnCall map[int]struct {
		result1 error
	}
	GetBackgroundTasksStub        func(domain.ToolService) []domain.TaskPollingState
	getBackgroundTasksMutex       sync.RWMutex
	getBackgroundTasksArgsForCall []struct {
		arg1 domain.ToolService
	}
	getBackgroundTasksReturns struct {
		result1 []domain.TaskPollingState
	}
	getBackgroundTasksReturnsOnCall map[int]struct {
		result1 []domain.TaskPollingState
	}
	GetChatSessionStub        func() *domain.ChatSession
	getChatSessionMutex       sync.RWMutex
	getChatSessionArgsForCall []struct {
	}
	getChatSessionReturns struct {
		result1 *domain.ChatSession
	}
	getChatSessionReturnsOnCall map[int]struct {
		result1 *domain.ChatSession
	}
	GetCurrentViewStub        func() domain.ViewState
	getCurrentViewMutex       sync.RWMutex
	getCurrentViewArgsForCall []struct {
	}
	getCurrentViewReturns struct {
		result1 domain.ViewState
	}
	getCurrentViewReturnsOnCall map[int]struct {
		result1 domain.ViewState
	}
	GetDimensionsStub        func() (int, int)
	getDimensionsMutex       sync.RWMutex
	getDimensionsArgsForCall []struct {
	}
	getDimensionsReturns struct {
		result1 int
		result2 int
	}
	getDimensionsReturnsOnCall map[int]struct {
		result1 int
		result2 int
	}
	GetFileSelectionStateStub        func() *domain.FileSelectionState
	getFileSelectionStateMutex       sync.RWMutex
	getFileSelectionStateArgsForCall []struct {
	}
	getFileSelectionStateReturns struct {
		result1 *domain.FileSelectionState
	}
	getFileSelectionStateReturnsOnCall map[int]struct {
		result1 *domain.FileSelectionState
	}
	GetMaxTaskRetentionStub        func() int
	getMaxTaskRetentionMutex       sync.RWMutex
	getMaxTaskRetentionArgsForCall []struct {
	}
	getMaxTaskRetentionReturns struct {
		result1 int
	}
	getMaxTaskRetentionReturnsOnCall map[int]struct {
		result1 int
	}
	GetQueuedMessagesStub        func() []domain.QueuedMessage
	getQueuedMessagesMutex       sync.RWMutex
	getQueuedMessagesArgsForCall []struct {
	}
	getQueuedMessagesReturns struct {
		result1 []domain.QueuedMessage
	}
	getQueuedMessagesReturnsOnCall map[int]struct {
		result1 []domain.QueuedMessage
	}
	GetRetainedTasksStub        func() []domain.RetainedTaskInfo
	getRetainedTasksMutex       sync.RWMutex
	getRetainedTasksArgsForCall []struct {
	}
	getRetainedTasksReturns struct {
		result1 []domain.RetainedTaskInfo
	}
	getRetainedTasksReturnsOnCall map[int]struct {
		result1 []domain.RetainedTaskInfo
	}
	GetToolExecutionStub        func() *domain.ToolExecutionSession
	getToolExecutionMutex       sync.RWMutex
	getToolExecutionArgsForCall []struct {
	}
	getToolExecutionReturns struct {
		result1 *domain.ToolExecutionSession
	}
	getToolExecutionReturnsOnCall map[int]struct {
		result1 *domain.ToolExecutionSession
	}
	IsAgentBusyStub        func() bool
	isAgentBusyMutex       sync.RWMutex
	isAgentBusyArgsForCall []struct {
	}
	isAgentBusyReturns struct {
		result1 bool
	}
	isAgentBusyReturnsOnCall map[int]struct {
		result1 bool
	}
	PopQueuedMessageStub        func() *domain.QueuedMessage
	popQueuedMessageMutex       sync.RWMutex
	popQueuedMessageArgsForCall []struct {
	}
	popQueuedMessageReturns struct {
		result1 *domain.QueuedMessage
	}
	popQueuedMessageReturnsOnCall map[int]struct {
		result1 *domain.QueuedMessage
	}
	SetDimensionsStub        func(int, int)
	setDimensionsMutex       sync.RWMutex
	setDimensionsArgsForCall []struct {
		arg1 int
		arg2 int
	}
	SetFileSelectedIndexStub        func(int)
	setFileSelectedIndexMutex       sync.RWMutex
	setFileSelectedIndexArgsForCall []struct {
		arg1 int
	}
	SetMaxTaskRetentionStub        func(int)
	setMaxTaskRetentionMutex       sync.RWMutex
	setMaxTaskRetentionArgsForCall []struct {
		arg1 int
	}
	SetupFileSelectionStub        func([]string)
	setupFileSelectionMutex       sync.RWMutex
	setupFileSelectionArgsForCall []struct {
		arg1 []string
	}
	StartChatSessionStub        func(string, string, <-chan domain.ChatEvent) error
	startChatSessionMutex       sync.RWMutex
	startChatSessionArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 <-chan domain.ChatEvent
	}
	startChatSessionReturns struct {
		result1 error
	}
	startChatSessionReturnsOnCall map[int]struct {
		result1 error
	}
	StartToolExecutionStub        func([]sdk.ChatCompletionMessageToolCall) error
	startToolExecutionMutex       sync.RWMutex
	startToolExecutionArgsForCall []struct {
		arg1 []sdk.ChatCompletionMessageToolCall
	}
	startToolExecutionReturns struct {
		result1 error
	}
	startToolExecutionReturnsOnCall map[int]struct {
		result1 error
	}
	TransitionToViewStub        func(domain.ViewState) error
	transitionToViewMutex       sync.RWMutex
	transitionToViewArgsForCall []struct {
		arg1 domain.ViewState
	}
	transitionToViewReturns struct {
		result1 error
	}
	transitionToViewReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateChatStatusStub        func(domain.ChatStatus) error
	updateChatStatusMutex       sync.RWMutex
	updateChatStatusArgsForCall []struct {
		arg1 domain.ChatStatus
	}
	updateChatStatusReturns struct {
		result1 error
	}
	updateChatStatusReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateFileSearchQueryStub        func(string)
	updateFileSearchQueryMutex       sync.RWMutex
	updateFileSearchQueryArgsForCall []struct {
		arg1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStateManager) AddQueuedMessage(arg1 domain.Message, arg2 string) {
	fake.addQueuedMessageMutex.Lock()
	fake.addQueuedMessageArgsForCall = append(fake.addQueuedMessageArgsForCall, struct {
		arg1 domain.Message
		arg2 string
	}{arg1, arg2})
	stub := fake.AddQueuedMessageStub
	fake.recordInvocation("AddQueuedMessage", []interface{}{arg1, arg2})
	fake.addQueuedMessageMutex.Unlock()
	if stub != nil {
		fake.AddQueuedMessageStub(arg1, arg2)
	}
}

func (fake *FakeStateManager) AddQueuedMessageCallCount() int {
	fake.addQueuedMessageMutex.RLock()
	defer fake.addQueuedMessageMutex.RUnlock()
	return len(fake.addQueuedMessageArgsForCall)
}

func (fake *FakeStateManager) AddQueuedMessageCalls(stub func(domain.Message, string)) {
	fake.addQueuedMessageMutex.Lock()
	defer fake.addQueuedMessageMutex.Unlock()
	fake.AddQueuedMessageStub = stub
}

func (fake *FakeStateManager) AddQueuedMessageArgsForCall(i int) (domain.Message, string) {
	fake.addQueuedMessageMutex.RLock()
	defer fake.addQueuedMessageMutex.RUnlock()
	argsForCall := fake.addQueuedMessageArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStateManager) AddTaskToInMemoryRetention(arg1 domain.RetainedTaskInfo) {
	fake.addTaskToInMemoryRetentionMutex.Lock()
	fake.addTaskToInMemoryRetentionArgsForCall = append(fake.addTaskToInMemoryRetentionArgsForCall, struct {
		arg1 domain.RetainedTaskInfo
	}{arg1})
	stub := fake.AddTaskToInMemoryRetentionStub
	fake.recordInvocation("AddTaskToInMemoryRetention", []interface{}{arg1})
	fake.addTaskToInMemoryRetentionMutex.Unlock()
	if stub != nil {
		fake.AddTaskToInMemoryRetentionStub(arg1)
	}
}

func (fake *FakeStateManager) AddTaskToInMemoryRetentionCallCount() int {
	fake.addTaskToInMemoryRetentionMutex.RLock()
	defer fake.addTaskToInMemoryRetentionMutex.RUnlock()
	return len(fake.addTaskToInMemoryRetentionArgsForCall)
}

func (fake *FakeStateManager) AddTaskToInMemoryRetentionCalls(stub func(domain.RetainedTaskInfo)) {
	fake.addTaskToInMemoryRetentionMutex.Lock()
	defer fake.addTaskToInMemoryRetentionMutex.Unlock()
	fake.AddTaskToInMemoryRetentionStub = stub
}

func (fake *FakeStateManager) AddTaskToInMemoryRetentionArgsForCall(i int) domain.RetainedTaskInfo {
	fake.addTaskToInMemoryRetentionMutex.RLock()
	defer fake.addTaskToInMemoryRetentionMutex.RUnlock()
	argsForCall := fake.addTaskToInMemoryRetentionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) CancelBackgroundTask(arg1 string, arg2 domain.ToolService) error {
	fake.cancelBackgroundTaskMutex.Lock()
	ret, specificReturn := fake.cancelBackgroundTaskReturnsOnCall[len(fake.cancelBackgroundTaskArgsForCall)]
	fake.cancelBackgroundTaskArgsForCall = append(fake.cancelBackgroundTaskArgsForCall, struct {
		arg1 string
		arg2 domain.ToolService
	}{arg1, arg2})
	stub := fake.CancelBackgroundTaskStub
	fakeReturns := fake.cancelBackgroundTaskReturns
	fake.recordInvocation("CancelBackgroundTask", []interface{}{arg1, arg2})
	fake.cancelBackgroundTaskMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) CancelBackgroundTaskCallCount() int {
	fake.cancelBackgroundTaskMutex.RLock()
	defer fake.cancelBackgroundTaskMutex.RUnlock()
	return len(fake.cancelBackgroundTaskArgsForCall)
}

func (fake *FakeStateManager) CancelBackgroundTaskCalls(stub func(string, domain.ToolService) error) {
	fake.cancelBackgroundTaskMutex.Lock()
	defer fake.cancelBackgroundTaskMutex.Unlock()
	fake.CancelBackgroundTaskStub = stub
}

func (fake *FakeStateManager) CancelBackgroundTaskArgsForCall(i int) (string, domain.ToolService) {
	fake.cancelBackgroundTaskMutex.RLock()
	defer fake.cancelBackgroundTaskMutex.RUnlock()
	argsForCall := fake.cancelBackgroundTaskArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStateManager) CancelBackgroundTaskReturns(result1 error) {
	fake.cancelBackgroundTaskMutex.Lock()
	defer fake.cancelBackgroundTaskMutex.Unlock()
	fake.CancelBackgroundTaskStub = nil
	fake.cancelBackgroundTaskReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) CancelBackgroundTaskReturnsOnCall(i int, result1 error) {
	fake.cancelBackgroundTaskMutex.Lock()
	defer fake.cancelBackgroundTaskMutex.Unlock()
	fake.CancelBackgroundTaskStub = nil
	if fake.cancelBackgroundTaskReturnsOnCall == nil {
		fake.cancelBackgroundTaskReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.cancelBackgroundTaskReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) ClearFileSelectionState() {
	fake.clearFileSelectionStateMutex.Lock()
	fake.clearFileSelectionStateArgsForCall = append(fake.clearFileSelectionStateArgsForCall, struct {
	}{})
	stub := fake.ClearFileSelectionStateStub
	fake.recordInvocation("ClearFileSelectionState", []interface{}{})
	fake.clearFileSelectionStateMutex.Unlock()
	if stub != nil {
		fake.ClearFileSelectionStateStub()
	}
}

func (fake *FakeStateManager) ClearFileSelectionStateCallCount() int {
	fake.clearFileSelectionStateMutex.RLock()
	defer fake.clearFileSelectionStateMutex.RUnlock()
	return len(fake.clearFileSelectionStateArgsForCall)
}

func (fake *FakeStateManager) ClearFileSelectionStateCalls(stub func()) {
	fake.clearFileSelectionStateMutex.Lock()
	defer fake.clearFileSelectionStateMutex.Unlock()
	fake.ClearFileSelectionStateStub = stub
}

func (fake *FakeStateManager) ClearQueuedMessages() {
	fake.clearQueuedMessagesMutex.Lock()
	fake.clearQueuedMessagesArgsForCall = append(fake.clearQueuedMessagesArgsForCall, struct {
	}{})
	stub := fake.ClearQueuedMessagesStub
	fake.recordInvocation("ClearQueuedMessages", []interface{}{})
	fake.clearQueuedMessagesMutex.Unlock()
	if stub != nil {
		fake.ClearQueuedMessagesStub()
	}
}

func (fake *FakeStateManager) ClearQueuedMessagesCallCount() int {
	fake.clearQueuedMessagesMutex.RLock()
	defer fake.clearQueuedMessagesMutex.RUnlock()
	return len(fake.clearQueuedMessagesArgsForCall)
}

func (fake *FakeStateManager) ClearQueuedMessagesCalls(stub func()) {
	fake.clearQueuedMessagesMutex.Lock()
	defer fake.clearQueuedMessagesMutex.Unlock()
	fake.ClearQueuedMessagesStub = stub
}

func (fake *FakeStateManager) ClearRetainedTasks() {
	fake.clearRetainedTasksMutex.Lock()
	fake.clearRetainedTasksArgsForCall = append(fake.clearRetainedTasksArgsForCall, struct {
	}{})
	stub := fake.ClearRetainedTasksStub
	fake.recordInvocation("ClearRetainedTasks", []interface{}{})
	fake.clearRetainedTasksMutex.Unlock()
	if stub != nil {
		fake.ClearRetainedTasksStub()
	}
}

func (fake *FakeStateManager) ClearRetainedTasksCallCount() int {
	fake.clearRetainedTasksMutex.RLock()
	defer fake.clearRetainedTasksMutex.RUnlock()
	return len(fake.clearRetainedTasksArgsForCall)
}

func (fake *FakeStateManager) ClearRetainedTasksCalls(stub func()) {
	fake.clearRetainedTasksMutex.Lock()
	defer fake.clearRetainedTasksMutex.Unlock()
	fake.ClearRetainedTasksStub = stub
}

func (fake *FakeStateManager) CompleteCurrentTool(arg1 *domain.ToolExecutionResult) error {
	fake.completeCurrentToolMutex.Lock()
	ret, specificReturn := fake.completeCurrentToolReturnsOnCall[len(fake.completeCurrentToolArgsForCall)]
	fake.completeCurrentToolArgsForCall = append(fake.completeCurrentToolArgsForCall, struct {
		arg1 *domain.ToolExecutionResult
	}{arg1})
	stub := fake.CompleteCurrentToolStub
	fakeReturns := fake.completeCurrentToolReturns
	fake.recordInvocation("CompleteCurrentTool", []interface{}{arg1})
	fake.completeCurrentToolMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) CompleteCurrentToolCallCount() int {
	fake.completeCurrentToolMutex.RLock()
	defer fake.completeCurrentToolMutex.RUnlock()
	return len(fake.completeCurrentToolArgsForCall)
}

func (fake *FakeStateManager) CompleteCurrentToolCalls(stub func(*domain.ToolExecutionResult) error) {
	fake.completeCurrentToolMutex.Lock()
	defer fake.completeCurrentToolMutex.Unlock()
	fake.CompleteCurrentToolStub = stub
}

func (fake *FakeStateManager) CompleteCurrentToolArgsForCall(i int) *domain.ToolExecutionResult {
	fake.completeCurrentToolMutex.RLock()
	defer fake.completeCurrentToolMutex.RUnlock()
	argsForCall := fake.completeCurrentToolArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) CompleteCurrentToolReturns(result1 error) {
	fake.completeCurrentToolMutex.Lock()
	defer fake.completeCurrentToolMutex.Unlock()
	fake.CompleteCurrentToolStub = nil
	fake.completeCurrentToolReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) CompleteCurrentToolReturnsOnCall(i int, result1 error) {
	fake.completeCurrentToolMutex.Lock()
	defer fake.completeCurrentToolMutex.Unlock()
	fake.CompleteCurrentToolStub = nil
	if fake.completeCurrentToolReturnsOnCall == nil {
		fake.completeCurrentToolReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.completeCurrentToolReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) EndChatSession() {
	fake.endChatSessionMutex.Lock()
	fake.endChatSessionArgsForCall = append(fake.endChatSessionArgsForCall, struct {
	}{})
	stub := fake.EndChatSessionStub
	fake.recordInvocation("EndChatSession", []interface{}{})
	fake.endChatSessionMutex.Unlock()
	if stub != nil {
		fake.EndChatSessionStub()
	}
}

func (fake *FakeStateManager) EndChatSessionCallCount() int {
	fake.endChatSessionMutex.RLock()
	defer fake.endChatSessionMutex.RUnlock()
	return len(fake.endChatSessionArgsForCall)
}

func (fake *FakeStateManager) EndChatSessionCalls(stub func()) {
	fake.endChatSessionMutex.Lock()
	defer fake.endChatSessionMutex.Unlock()
	fake.EndChatSessionStub = stub
}

func (fake *FakeStateManager) EndToolExecution() {
	fake.endToolExecutionMutex.Lock()
	fake.endToolExecutionArgsForCall = append(fake.endToolExecutionArgsForCall, struct {
	}{})
	stub := fake.EndToolExecutionStub
	fake.recordInvocation("EndToolExecution", []interface{}{})
	fake.endToolExecutionMutex.Unlock()
	if stub != nil {
		fake.EndToolExecutionStub()
	}
}

func (fake *FakeStateManager) EndToolExecutionCallCount() int {
	fake.endToolExecutionMutex.RLock()
	defer fake.endToolExecutionMutex.RUnlock()
	return len(fake.endToolExecutionArgsForCall)
}

func (fake *FakeStateManager) EndToolExecutionCalls(stub func()) {
	fake.endToolExecutionMutex.Lock()
	defer fake.endToolExecutionMutex.Unlock()
	fake.EndToolExecutionStub = stub
}

func (fake *FakeStateManager) FailCurrentTool(arg1 *domain.ToolExecutionResult) error {
	fake.failCurrentToolMutex.Lock()
	ret, specificReturn := fake.failCurrentToolReturnsOnCall[len(fake.failCurrentToolArgsForCall)]
	fake.failCurrentToolArgsForCall = append(fake.failCurrentToolArgsForCall, struct {
		arg1 *domain.ToolExecutionResult
	}{arg1})
	stub := fake.FailCurrentToolStub
	fakeReturns := fake.failCurrentToolReturns
	fake.recordInvocation("FailCurrentTool", []interface{}{arg1})
	fake.failCurrentToolMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) FailCurrentToolCallCount() int {
	fake.failCurrentToolMutex.RLock()
	defer fake.failCurrentToolMutex.RUnlock()
	return len(fake.failCurrentToolArgsForCall)
}

func (fake *FakeStateManager) FailCurrentToolCalls(stub func(*domain.ToolExecutionResult) error) {
	fake.failCurrentToolMutex.Lock()
	defer fake.failCurrentToolMutex.Unlock()
	fake.FailCurrentToolStub = stub
}

func (fake *FakeStateManager) FailCurrentToolArgsForCall(i int) *domain.ToolExecutionResult {
	fake.failCurrentToolMutex.RLock()
	defer fake.failCurrentToolMutex.RUnlock()
	argsForCall := fake.failCurrentToolArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) FailCurrentToolReturns(result1 error) {
	fake.failCurrentToolMutex.Lock()
	defer fake.failCurrentToolMutex.Unlock()
	fake.FailCurrentToolStub = nil
	fake.failCurrentToolReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) FailCurrentToolReturnsOnCall(i int, result1 error) {
	fake.failCurrentToolMutex.Lock()
	defer fake.failCurrentToolMutex.Unlock()
	fake.FailCurrentToolStub = nil
	if fake.failCurrentToolReturnsOnCall == nil {
		fake.failCurrentToolReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.failCurrentToolReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) GetBackgroundTasks(arg1 domain.ToolService) []domain.TaskPollingState {
	fake.getBackgroundTasksMutex.Lock()
	ret, specificReturn := fake.getBackgroundTasksReturnsOnCall[len(fake.getBackgroundTasksArgsForCall)]
	fake.getBackgroundTasksArgsForCall = append(fake.getBackgroundTasksArgsForCall, struct {
		arg1 domain.ToolService
	}{arg1})
	stub := fake.GetBackgroundTasksStub
	fakeReturns := fake.getBackgroundTasksReturns
	fake.recordInvocation("GetBackgroundTasks", []interface{}{arg1})
	fake.getBackgroundTasksMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetBackgroundTasksCallCount() int {
	fake.getBackgroundTasksMutex.RLock()
	defer fake.getBackgroundTasksMutex.RUnlock()
	return len(fake.getBackgroundTasksArgsForCall)
}

func (fake *FakeStateManager) GetBackgroundTasksCalls(stub func(domain.ToolService) []domain.TaskPollingState) {
	fake.getBackgroundTasksMutex.Lock()
	defer fake.getBackgroundTasksMutex.Unlock()
	fake.GetBackgroundTasksStub = stub
}

func (fake *FakeStateManager) GetBackgroundTasksArgsForCall(i int) domain.ToolService {
	fake.getBackgroundTasksMutex.RLock()
	defer fake.getBackgroundTasksMutex.RUnlock()
	argsForCall := fake.getBackgroundTasksArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) GetBackgroundTasksReturns(result1 []domain.TaskPollingState) {
	fake.getBackgroundTasksMutex.Lock()
	defer fake.getBackgroundTasksMutex.Unlock()
	fake.GetBackgroundTasksStub = nil
	fake.getBackgroundTasksReturns = struct {
		result1 []domain.TaskPollingState
	}{result1}
}

func (fake *FakeStateManager) GetBackgroundTasksReturnsOnCall(i int, result1 []domain.TaskPollingState) {
	fake.getBackgroundTasksMutex.Lock()
	defer fake.getBackgroundTasksMutex.Unlock()
	fake.GetBackgroundTasksStub = nil
	if fake.getBackgroundTasksReturnsOnCall == nil {
		fake.getBackgroundTasksReturnsOnCall = make(map[int]struct {
			result1 []domain.TaskPollingState
		})
	}
	fake.getBackgroundTasksReturnsOnCall[i] = struct {
		result1 []domain.TaskPollingState
	}{result1}
}

func (fake *FakeStateManager) GetChatSession() *domain.ChatSession {
	fake.getChatSessionMutex.Lock()
	ret, specificReturn := fake.getChatSessionReturnsOnCall[len(fake.getChatSessionArgsForCall)]
	fake.getChatSessionArgsForCall = append(fake.getChatSessionArgsForCall, struct {
	}{})
	stub := fake.GetChatSessionStub
	fakeReturns := fake.getChatSessionReturns
	fake.recordInvocation("GetChatSession", []interface{}{})
	fake.getChatSessionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetChatSessionCallCount() int {
	fake.getChatSessionMutex.RLock()
	defer fake.getChatSessionMutex.RUnlock()
	return len(fake.getChatSessionArgsForCall)
}

func (fake *FakeStateManager) GetChatSessionCalls(stub func() *domain.ChatSession) {
	fake.getChatSessionMutex.Lock()
	defer fake.getChatSessionMutex.Unlock()
	fake.GetChatSessionStub = stub
}

func (fake *FakeStateManager) GetChatSessionReturns(result1 *domain.ChatSession) {
	fake.getChatSessionMutex.Lock()
	defer fake.getChatSessionMutex.Unlock()
	fake.GetChatSessionStub = nil
	fake.getChatSessionReturns = struct {
		result1 *domain.ChatSession
	}{result1}
}

func (fake *FakeStateManager) GetChatSessionReturnsOnCall(i int, result1 *domain.ChatSession) {
	fake.getChatSessionMutex.Lock()
	defer fake.getChatSessionMutex.Unlock()
	fake.GetChatSessionStub = nil
	if fake.getChatSessionReturnsOnCall == nil {
		fake.getChatSessionReturnsOnCall = make(map[int]struct {
			result1 *domain.ChatSession
		})
	}
	fake.getChatSessionReturnsOnCall[i] = struct {
		result1 *domain.ChatSession
	}{result1}
}

func (fake *FakeStateManager) GetCurrentView() domain.ViewState {
	fake.getCurrentViewMutex.Lock()
	ret, specificReturn := fake.getCurrentViewReturnsOnCall[len(fake.getCurrentViewArgsForCall)]
	fake.getCurrentViewArgsForCall = append(fake.getCurrentViewArgsForCall, struct {
	}{})
	stub := fake.GetCurrentViewStub
	fakeReturns := fake.getCurrentViewReturns
	fake.recordInvocation("GetCurrentView", []interface{}{})
	fake.getCurrentViewMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetCurrentViewCallCount() int {
	fake.getCurrentViewMutex.RLock()
	defer fake.getCurrentViewMutex.RUnlock()
	return len(fake.getCurrentViewArgsForCall)
}

func (fake *FakeStateManager) GetCurrentViewCalls(stub func() domain.ViewState) {
	fake.getCurrentViewMutex.Lock()
	defer fake.getCurrentViewMutex.Unlock()
	fake.GetCurrentViewStub = stub
}

func (fake *FakeStateManager) GetCurrentViewReturns(result1 domain.ViewState) {
	fake.getCurrentViewMutex.Lock()
	defer fake.getCurrentViewMutex.Unlock()
	fake.GetCurrentViewStub = nil
	fake.getCurrentViewReturns = struct {
		result1 domain.ViewState
	}{result1}
}

func (fake *FakeStateManager) GetCurrentViewReturnsOnCall(i int, result1 domain.ViewState) {
	fake.getCurrentViewMutex.Lock()
	defer fake.getCurrentViewMutex.Unlock()
	fake.GetCurrentViewStub = nil
	if fake.getCurrentViewReturnsOnCall == nil {
		fake.getCurrentViewReturnsOnCall = make(map[int]struct {
			result1 domain.ViewState
		})
	}
	fake.getCurrentViewReturnsOnCall[i] = struct {
		result1 domain.ViewState
	}{result1}
}

func (fake *FakeStateManager) GetDimensions() (int, int) {
	fake.getDimensionsMutex.Lock()
	ret, specificReturn := fake.getDimensionsReturnsOnCall[len(fake.getDimensionsArgsForCall)]
	fake.getDimensionsArgsForCall = append(fake.getDimensionsArgsForCall, struct {
	}{})
	stub := fake.GetDimensionsStub
	fakeReturns := fake.getDimensionsReturns
	fake.recordInvocation("GetDimensions", []interface{}{})
	fake.getDimensionsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStateManager) GetDimensionsCallCount() int {
	fake.getDimensionsMutex.RLock()
	defer fake.getDimensionsMutex.RUnlock()
	return len(fake.getDimensionsArgsForCall)
}

func (fake *FakeStateManager) GetDimensionsCalls(stub func() (int, int)) {
	fake.getDimensionsMutex.Lock()
	defer fake.getDimensionsMutex.Unlock()
	fake.GetDimensionsStub = stub
}

func (fake *FakeStateManager) GetDimensionsReturns(result1 int, result2 int) {
	fake.getDimensionsMutex.Lock()
	defer fake.getDimensionsMutex.Unlock()
	fake.GetDimensionsStub = nil
	fake.getDimensionsReturns = struct {
		result1 int
		result2 int
	}{result1, result2}
}

func (fake *FakeStateManager) GetDimensionsReturnsOnCall(i int, result1 int, result2 int) {
	fake.getDimensionsMutex.Lock()
	defer fake.getDimensionsMutex.Unlock()
	fake.GetDimensionsStub = nil
	if fake.getDimensionsReturnsOnCall == nil {
		fake.getDimensionsReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
		})
	}
	fake.getDimensionsReturnsOnCall[i] = struct {
		result1 int
		result2 int
	}{result1, result2}
}

func (fake *FakeStateManager) GetFileSelectionState() *domain.FileSelectionState {
	fake.getFileSelectionStateMutex.Lock()
	ret, specificReturn := fake.getFileSelectionStateReturnsOnCall[len(fake.getFileSelectionStateArgsForCall)]
	fake.getFileSelectionStateArgsForCall = append(fake.getFileSelectionStateArgsForCall, struct {
	}{})
	stub := fake.GetFileSelectionStateStub
	fakeReturns := fake.getFileSelectionStateReturns
	fake.recordInvocation("GetFileSelectionState", []interface{}{})
	fake.getFileSelectionStateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetFileSelectionStateCallCount() int {
	fake.getFileSelectionStateMutex.RLock()
	defer fake.getFileSelectionStateMutex.RUnlock()
	return len(fake.getFileSelectionStateArgsForCall)
}

func (fake *FakeStateManager) GetFileSelectionStateCalls(stub func() *domain.FileSelectionState) {
	fake.getFileSelectionStateMutex.Lock()
	defer fake.getFileSelectionStateMutex.Unlock()
	fake.GetFileSelectionStateStub = stub
}

func (fake *FakeStateManager) GetFileSelectionStateReturns(result1 *domain.FileSelectionState) {
	fake.getFileSelectionStateMutex.Lock()
	defer fake.getFileSelectionStateMutex.Unlock()
	fake.GetFileSelectionStateStub = nil
	fake.getFileSelectionStateReturns = struct {
		result1 *domain.FileSelectionState
	}{result1}
}

func (fake *FakeStateManager) GetFileSelectionStateReturnsOnCall(i int, result1 *domain.FileSelectionState) {
	fake.getFileSelectionStateMutex.Lock()
	defer fake.getFileSelectionStateMutex.Unlock()
	fake.GetFileSelectionStateStub = nil
	if fake.getFileSelectionStateReturnsOnCall == nil {
		fake.getFileSelectionStateReturnsOnCall = make(map[int]struct {
			result1 *domain.FileSelectionState
		})
	}
	fake.getFileSelectionStateReturnsOnCall[i] = struct {
		result1 *domain.FileSelectionState
	}{result1}
}

func (fake *FakeStateManager) GetMaxTaskRetention() int {
	fake.getMaxTaskRetentionMutex.Lock()
	ret, specificReturn := fake.getMaxTaskRetentionReturnsOnCall[len(fake.getMaxTaskRetentionArgsForCall)]
	fake.getMaxTaskRetentionArgsForCall = append(fake.getMaxTaskRetentionArgsForCall, struct {
	}{})
	stub := fake.GetMaxTaskRetentionStub
	fakeReturns := fake.getMaxTaskRetentionReturns
	fake.recordInvocation("GetMaxTaskRetention", []interface{}{})
	fake.getMaxTaskRetentionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetMaxTaskRetentionCallCount() int {
	fake.getMaxTaskRetentionMutex.RLock()
	defer fake.getMaxTaskRetentionMutex.RUnlock()
	return len(fake.getMaxTaskRetentionArgsForCall)
}

func (fake *FakeStateManager) GetMaxTaskRetentionCalls(stub func() int) {
	fake.getMaxTaskRetentionMutex.Lock()
	defer fake.getMaxTaskRetentionMutex.Unlock()
	fake.GetMaxTaskRetentionStub = stub
}

func (fake *FakeStateManager) GetMaxTaskRetentionReturns(result1 int) {
	fake.getMaxTaskRetentionMutex.Lock()
	defer fake.getMaxTaskRetentionMutex.Unlock()
	fake.GetMaxTaskRetentionStub = nil
	fake.getMaxTaskRetentionReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeStateManager) GetMaxTaskRetentionReturnsOnCall(i int, result1 int) {
	fake.getMaxTaskRetentionMutex.Lock()
	defer fake.getMaxTaskRetentionMutex.Unlock()
	fake.GetMaxTaskRetentionStub = nil
	if fake.getMaxTaskRetentionReturnsOnCall == nil {
		fake.getMaxTaskRetentionReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getMaxTaskRetentionReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeStateManager) GetQueuedMessages() []domain.QueuedMessage {
	fake.getQueuedMessagesMutex.Lock()
	ret, specificReturn := fake.getQueuedMessagesReturnsOnCall[len(fake.getQueuedMessagesArgsForCall)]
	fake.getQueuedMessagesArgsForCall = append(fake.getQueuedMessagesArgsForCall, struct {
	}{})
	stub := fake.GetQueuedMessagesStub
	fakeReturns := fake.getQueuedMessagesReturns
	fake.recordInvocation("GetQueuedMessages", []interface{}{})
	fake.getQueuedMessagesMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetQueuedMessagesCallCount() int {
	fake.getQueuedMessagesMutex.RLock()
	defer fake.getQueuedMessagesMutex.RUnlock()
	return len(fake.getQueuedMessagesArgsForCall)
}

func (fake *FakeStateManager) GetQueuedMessagesCalls(stub func() []domain.QueuedMessage) {
	fake.getQueuedMessagesMutex.Lock()
	defer fake.getQueuedMessagesMutex.Unlock()
	fake.GetQueuedMessagesStub = stub
}

func (fake *FakeStateManager) GetQueuedMessagesReturns(result1 []domain.QueuedMessage) {
	fake.getQueuedMessagesMutex.Lock()
	defer fake.getQueuedMessagesMutex.Unlock()
	fake.GetQueuedMessagesStub = nil
	fake.getQueuedMessagesReturns = struct {
		result1 []domain.QueuedMessage
	}{result1}
}

func (fake *FakeStateManager) GetQueuedMessagesReturnsOnCall(i int, result1 []domain.QueuedMessage) {
	fake.getQueuedMessagesMutex.Lock()
	defer fake.getQueuedMessagesMutex.Unlock()
	fake.GetQueuedMessagesStub = nil
	if fake.getQueuedMessagesReturnsOnCall == nil {
		fake.getQueuedMessagesReturnsOnCall = make(map[int]struct {
			result1 []domain.QueuedMessage
		})
	}
	fake.getQueuedMessagesReturnsOnCall[i] = struct {
		result1 []domain.QueuedMessage
	}{result1}
}

func (fake *FakeStateManager) GetRetainedTasks() []domain.RetainedTaskInfo {
	fake.getRetainedTasksMutex.Lock()
	ret, specificReturn := fake.getRetainedTasksReturnsOnCall[len(fake.getRetainedTasksArgsForCall)]
	fake.getRetainedTasksArgsForCall = append(fake.getRetainedTasksArgsForCall, struct {
	}{})
	stub := fake.GetRetainedTasksStub
	fakeReturns := fake.getRetainedTasksReturns
	fake.recordInvocation("GetRetainedTasks", []interface{}{})
	fake.getRetainedTasksMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetRetainedTasksCallCount() int {
	fake.getRetainedTasksMutex.RLock()
	defer fake.getRetainedTasksMutex.RUnlock()
	return len(fake.getRetainedTasksArgsForCall)
}

func (fake *FakeStateManager) GetRetainedTasksCalls(stub func() []domain.RetainedTaskInfo) {
	fake.getRetainedTasksMutex.Lock()
	defer fake.getRetainedTasksMutex.Unlock()
	fake.GetRetainedTasksStub = stub
}

func (fake *FakeStateManager) GetRetainedTasksReturns(result1 []domain.RetainedTaskInfo) {
	fake.getRetainedTasksMutex.Lock()
	defer fake.getRetainedTasksMutex.Unlock()
	fake.GetRetainedTasksStub = nil
	fake.getRetainedTasksReturns = struct {
		result1 []domain.RetainedTaskInfo
	}{result1}
}

func (fake *FakeStateManager) GetRetainedTasksReturnsOnCall(i int, result1 []domain.RetainedTaskInfo) {
	fake.getRetainedTasksMutex.Lock()
	defer fake.getRetainedTasksMutex.Unlock()
	fake.GetRetainedTasksStub = nil
	if fake.getRetainedTasksReturnsOnCall == nil {
		fake.getRetainedTasksReturnsOnCall = make(map[int]struct {
			result1 []domain.RetainedTaskInfo
		})
	}
	fake.getRetainedTasksReturnsOnCall[i] = struct {
		result1 []domain.RetainedTaskInfo
	}{result1}
}

func (fake *FakeStateManager) GetToolExecution() *domain.ToolExecutionSession {
	fake.getToolExecutionMutex.Lock()
	ret, specificReturn := fake.getToolExecutionReturnsOnCall[len(fake.getToolExecutionArgsForCall)]
	fake.getToolExecutionArgsForCall = append(fake.getToolExecutionArgsForCall, struct {
	}{})
	stub := fake.GetToolExecutionStub
	fakeReturns := fake.getToolExecutionReturns
	fake.recordInvocation("GetToolExecution", []interface{}{})
	fake.getToolExecutionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetToolExecutionCallCount() int {
	fake.getToolExecutionMutex.RLock()
	defer fake.getToolExecutionMutex.RUnlock()
	return len(fake.getToolExecutionArgsForCall)
}

func (fake *FakeStateManager) GetToolExecutionCalls(stub func() *domain.ToolExecutionSession) {
	fake.getToolExecutionMutex.Lock()
	defer fake.getToolExecutionMutex.Unlock()
	fake.GetToolExecutionStub = stub
}

func (fake *FakeStateManager) GetToolExecutionReturns(result1 *domain.ToolExecutionSession) {
	fake.getToolExecutionMutex.Lock()
	defer fake.getToolExecutionMutex.Unlock()
	fake.GetToolExecutionStub = nil
	fake.getToolExecutionReturns = struct {
		result1 *domain.ToolExecutionSession
	}{result1}
}

func (fake *FakeStateManager) GetToolExecutionReturnsOnCall(i int, result1 *domain.ToolExecutionSession) {
	fake.getToolExecutionMutex.Lock()
	defer fake.getToolExecutionMutex.Unlock()
	fake.GetToolExecutionStub = nil
	if fake.getToolExecutionReturnsOnCall == nil {
		fake.getToolExecutionReturnsOnCall = make(map[int]struct {
			result1 *domain.ToolExecutionSession
		})
	}
	fake.getToolExecutionReturnsOnCall[i] = struct {
		result1 *domain.ToolExecutionSession
	}{result1}
}

func (fake *FakeStateManager) IsAgentBusy() bool {
	fake.isAgentBusyMutex.Lock()
	ret, specificReturn := fake.isAgentBusyReturnsOnCall[len(fake.isAgentBusyArgsForCall)]
	fake.isAgentBusyArgsForCall = append(fake.isAgentBusyArgsForCall, struct {
	}{})
	stub := fake.IsAgentBusyStub
	fakeReturns := fake.isAgentBusyReturns
	fake.recordInvocation("IsAgentBusy", []interface{}{})
	fake.isAgentBusyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) IsAgentBusyCallCount() int {
	fake.isAgentBusyMutex.RLock()
	defer fake.isAgentBusyMutex.RUnlock()
	return len(fake.isAgentBusyArgsForCall)
}

func (fake *FakeStateManager) IsAgentBusyCalls(stub func() bool) {
	fake.isAgentBusyMutex.Lock()
	defer fake.isAgentBusyMutex.Unlock()
	fake.IsAgentBusyStub = stub
}

func (fake *FakeStateManager) IsAgentBusyReturns(result1 bool) {
	fake.isAgentBusyMutex.Lock()
	defer fake.isAgentBusyMutex.Unlock()
	fake.IsAgentBusyStub = nil
	fake.isAgentBusyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStateManager) IsAgentBusyReturnsOnCall(i int, result1 bool) {
	fake.isAgentBusyMutex.Lock()
	defer fake.isAgentBusyMutex.Unlock()
	fake.IsAgentBusyStub = nil
	if fake.isAgentBusyReturnsOnCall == nil {
		fake.isAgentBusyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isAgentBusyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStateManager) PopQueuedMessage() *domain.QueuedMessage {
	fake.popQueuedMessageMutex.Lock()
	ret, specificReturn := fake.popQueuedMessageReturnsOnCall[len(fake.popQueuedMessageArgsForCall)]
	fake.popQueuedMessageArgsForCall = append(fake.popQueuedMessageArgsForCall, struct {
	}{})
	stub := fake.PopQueuedMessageStub
	fakeReturns := fake.popQueuedMessageReturns
	fake.recordInvocation("PopQueuedMessage", []interface{}{})
	fake.popQueuedMessageMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) PopQueuedMessageCallCount() int {
	fake.popQueuedMessageMutex.RLock()
	defer fake.popQueuedMessageMutex.RUnlock()
	return len(fake.popQueuedMessageArgsForCall)
}

func (fake *FakeStateManager) PopQueuedMessageCalls(stub func() *domain.QueuedMessage) {
	fake.popQueuedMessageMutex.Lock()
	defer fake.popQueuedMessageMutex.Unlock()
	fake.PopQueuedMessageStub = stub
}

func (fake *FakeStateManager) PopQueuedMessageReturns(result1 *domain.QueuedMessage) {
	fake.popQueuedMessageMutex.Lock()
	defer fake.popQueuedMessageMutex.Unlock()
	fake.PopQueuedMessageStub = nil
	fake.popQueuedMessageReturns = struct {
		result1 *domain.QueuedMessage
	}{result1}
}

func (fake *FakeStateManager) PopQueuedMessageReturnsOnCall(i int, result1 *domain.QueuedMessage) {
	fake.popQueuedMessageMutex.Lock()
	defer fake.popQueuedMessageMutex.Unlock()
	fake.PopQueuedMessageStub = nil
	if fake.popQueuedMessageReturnsOnCall == nil {
		fake.popQueuedMessageReturnsOnCall = make(map[int]struct {
			result1 *domain.QueuedMessage
		})
	}
	fake.popQueuedMessageReturnsOnCall[i] = struct {
		result1 *domain.QueuedMessage
	}{result1}
}

func (fake *FakeStateManager) SetDimensions(arg1 int, arg2 int) {
	fake.setDimensionsMutex.Lock()
	fake.setDimensionsArgsForCall = append(fake.setDimensionsArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.SetDimensionsStub
	fake.recordInvocation("SetDimensions", []interface{}{arg1, arg2})
	fake.setDimensionsMutex.Unlock()
	if stub != nil {
		fake.SetDimensionsStub(arg1, arg2)
	}
}

func (fake *FakeStateManager) SetDimensionsCallCount() int {
	fake.setDimensionsMutex.RLock()
	defer fake.setDimensionsMutex.RUnlock()
	return len(fake.setDimensionsArgsForCall)
}

func (fake *FakeStateManager) SetDimensionsCalls(stub func(int, int)) {
	fake.setDimensionsMutex.Lock()
	defer fake.setDimensionsMutex.Unlock()
	fake.SetDimensionsStub = stub
}

func (fake *FakeStateManager) SetDimensionsArgsForCall(i int) (int, int) {
	fake.setDimensionsMutex.RLock()
	defer fake.setDimensionsMutex.RUnlock()
	argsForCall := fake.setDimensionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStateManager) SetFileSelectedIndex(arg1 int) {
	fake.setFileSelectedIndexMutex.Lock()
	fake.setFileSelectedIndexArgsForCall = append(fake.setFileSelectedIndexArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.SetFileSelectedIndexStub
	fake.recordInvocation("SetFileSelectedIndex", []interface{}{arg1})
	fake.setFileSelectedIndexMutex.Unlock()
	if stub != nil {
		fake.SetFileSelectedIndexStub(arg1)
	}
}

func (fake *FakeStateManager) SetFileSelectedIndexCallCount() int {
	fake.setFileSelectedIndexMutex.RLock()
	defer fake.setFileSelectedIndexMutex.RUnlock()
	return len(fake.setFileSelectedIndexArgsForCall)
}

func (fake *FakeStateManager) SetFileSelectedIndexCalls(stub func(int)) {
	fake.setFileSelectedIndexMutex.Lock()
	defer fake.setFileSelectedIndexMutex.Unlock()
	fake.SetFileSelectedIndexStub = stub
}

func (fake *FakeStateManager) SetFileSelectedIndexArgsForCall(i int) int {
	fake.setFileSelectedIndexMutex.RLock()
	defer fake.setFileSelectedIndexMutex.RUnlock()
	argsForCall := fake.setFileSelectedIndexArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) SetMaxTaskRetention(arg1 int) {
	fake.setMaxTaskRetentionMutex.Lock()
	fake.setMaxTaskRetentionArgsForCall = append(fake.setMaxTaskRetentionArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.SetMaxTaskRetentionStub
	fake.recordInvocation("SetMaxTaskRetention", []interface{}{arg1})
	fake.setMaxTaskRetentionMutex.Unlock()
	if stub != nil {
		fake.SetMaxTaskRetentionStub(arg1)
	}
}

func (fake *FakeStateManager) SetMaxTaskRetentionCallCount() int {
	fake.setMaxTaskRetentionMutex.RLock()
	defer fake.setMaxTaskRetentionMutex.RUnlock()
	return len(fake.setMaxTaskRetentionArgsForCall)
}

func (fake *FakeStateManager) SetMaxTaskRetentionCalls(stub func(int)) {
	fake.setMaxTaskRetentionMutex.Lock()
	defer fake.setMaxTaskRetentionMutex.Unlock()
	fake.SetMaxTaskRetentionStub = stub
}

func (fake *FakeStateManager) SetMaxTaskRetentionArgsForCall(i int) int {
	fake.setMaxTaskRetentionMutex.RLock()
	defer fake.setMaxTaskRetentionMutex.RUnlock()
	argsForCall := fake.setMaxTaskRetentionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) SetupFileSelection(arg1 []string) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setupFileSelectionMutex.Lock()
	fake.setupFileSelectionArgsForCall = append(fake.setupFileSelectionArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.SetupFileSelectionStub
	fake.recordInvocation("SetupFileSelection", []interface{}{arg1Copy})
	fake.setupFileSelectionMutex.Unlock()
	if stub != nil {
		fake.SetupFileSelectionStub(arg1)
	}
}

func (fake *FakeStateManager) SetupFileSelectionCallCount() int {
	fake.setupFileSelectionMutex.RLock()
	defer fake.setupFileSelectionMutex.RUnlock()
	return len(fake.setupFileSelectionArgsForCall)
}

func (fake *FakeStateManager) SetupFileSelectionCalls(stub func([]string)) {
	fake.setupFileSelectionMutex.Lock()
	defer fake.setupFileSelectionMutex.Unlock()
	fake.SetupFileSelectionStub = stub
}

func (fake *FakeStateManager) SetupFileSelectionArgsForCall(i int) []string {
	fake.setupFileSelectionMutex.RLock()
	defer fake.setupFileSelectionMutex.RUnlock()
	argsForCall := fake.setupFileSelectionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) StartChatSession(arg1 string, arg2 string, arg3 <-chan domain.ChatEvent) error {
	fake.startChatSessionMutex.Lock()
	ret, specificReturn := fake.startChatSessionReturnsOnCall[len(fake.startChatSessionArgsForCall)]
	fake.startChatSessionArgsForCall = append(fake.startChatSessionArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 <-chan domain.ChatEvent
	}{arg1, arg2, arg3})
	stub := fake.StartChatSessionStub
	fakeReturns := fake.startChatSessionReturns
	fake.recordInvocation("StartChatSession", []interface{}{arg1, arg2, arg3})
	fake.startChatSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) StartChatSessionCallCount() int {
	fake.startChatSessionMutex.RLock()
	defer fake.startChatSessionMutex.RUnlock()
	return len(fake.startChatSessionArgsForCall)
}

func (fake *FakeStateManager) StartChatSessionCalls(stub func(string, string, <-chan domain.ChatEvent) error) {
	fake.startChatSessionMutex.Lock()
	defer fake.startChatSessionMutex.Unlock()
	fake.StartChatSessionStub = stub
}

func (fake *FakeStateManager) StartChatSessionArgsForCall(i int) (string, string, <-chan domain.ChatEvent) {
	fake.startChatSessionMutex.RLock()
	defer fake.startChatSessionMutex.RUnlock()
	argsForCall := fake.startChatSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStateManager) StartChatSessionReturns(result1 error) {
	fake.startChatSessionMutex.Lock()
	defer fake.startChatSessionMutex.Unlock()
	fake.StartChatSessionStub = nil
	fake.startChatSessionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) StartChatSessionReturnsOnCall(i int, result1 error) {
	fake.startChatSessionMutex.Lock()
	defer fake.startChatSessionMutex.Unlock()
	fake.StartChatSessionStub = nil
	if fake.startChatSessionReturnsOnCall == nil {
		fake.startChatSessionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startChatSessionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) StartToolExecution(arg1 []sdk.ChatCompletionMessageToolCall) error {
	var arg1Copy []sdk.ChatCompletionMessageToolCall
	if arg1 != nil {
		arg1Copy = make([]sdk.ChatCompletionMessageToolCall, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.startToolExecutionMutex.Lock()
	ret, specificReturn := fake.startToolExecutionReturnsOnCall[len(fake.startToolExecutionArgsForCall)]
	fake.startToolExecutionArgsForCall = append(fake.startToolExecutionArgsForCall, struct {
		arg1 []sdk.ChatCompletionMessageToolCall
	}{arg1Copy})
	stub := fake.StartToolExecutionStub
	fakeReturns := fake.startToolExecutionReturns
	fake.recordInvocation("StartToolExecution", []interface{}{arg1Copy})
	fake.startToolExecutionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) StartToolExecutionCallCount() int {
	fake.startToolExecutionMutex.RLock()
	defer fake.startToolExecutionMutex.RUnlock()
	return len(fake.startToolExecutionArgsForCall)
}

func (fake *FakeStateManager) StartToolExecutionCalls(stub func([]sdk.ChatCompletionMessageToolCall) error) {
	fake.startToolExecutionMutex.Lock()
	defer fake.startToolExecutionMutex.Unlock()
	fake.StartToolExecutionStub = stub
}

func (fake *FakeStateManager) StartToolExecutionArgsForCall(i int) []sdk.ChatCompletionMessageToolCall {
	fake.startToolExecutionMutex.RLock()
	defer fake.startToolExecutionMutex.RUnlock()
	argsForCall := fake.startToolExecutionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) StartToolExecutionReturns(result1 error) {
	fake.startToolExecutionMutex.Lock()
	defer fake.startToolExecutionMutex.Unlock()
	fake.StartToolExecutionStub = nil
	fake.startToolExecutionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) StartToolExecutionReturnsOnCall(i int, result1 error) {
	fake.startToolExecutionMutex.Lock()
	defer fake.startToolExecutionMutex.Unlock()
	fake.StartToolExecutionStub = nil
	if fake.startToolExecutionReturnsOnCall == nil {
		fake.startToolExecutionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startToolExecutionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) TransitionToView(arg1 domain.ViewState) error {
	fake.transitionToViewMutex.Lock()
	ret, specificReturn := fake.transitionToViewReturnsOnCall[len(fake.transitionToViewArgsForCall)]
	fake.transitionToViewArgsForCall = append(fake.transitionToViewArgsForCall, struct {
		arg1 domain.ViewState
	}{arg1})
	stub := fake.TransitionToViewStub
	fakeReturns := fake.transitionToViewReturns
	fake.recordInvocation("TransitionToView", []interface{}{arg1})
	fake.transitionToViewMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) TransitionToViewCallCount() int {
	fake.transitionToViewMutex.RLock()
	defer fake.transitionToViewMutex.RUnlock()
	return len(fake.transitionToViewArgsForCall)
}

func (fake *FakeStateManager) TransitionToViewCalls(stub func(domain.ViewState) error) {
	fake.transitionToViewMutex.Lock()
	defer fake.transitionToViewMutex.Unlock()
	fake.TransitionToViewStub = stub
}

func (fake *FakeStateManager) TransitionToViewArgsForCall(i int) domain.ViewState {
	fake.transitionToViewMutex.RLock()
	defer fake.transitionToViewMutex.RUnlock()
	argsForCall := fake.transitionToViewArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) TransitionToViewReturns(result1 error) {
	fake.transitionToViewMutex.Lock()
	defer fake.transitionToViewMutex.Unlock()
	fake.TransitionToViewStub = nil
	fake.transitionToViewReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) TransitionToViewReturnsOnCall(i int, result1 error) {
	fake.transitionToViewMutex.Lock()
	defer fake.transitionToViewMutex.Unlock()
	fake.TransitionToViewStub = nil
	if fake.transitionToViewReturnsOnCall == nil {
		fake.transitionToViewReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.transitionToViewReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) UpdateChatStatus(arg1 domain.ChatStatus) error {
	fake.updateChatStatusMutex.Lock()
	ret, specificReturn := fake.updateChatStatusReturnsOnCall[len(fake.updateChatStatusArgsForCall)]
	fake.updateChatStatusArgsForCall = append(fake.updateChatStatusArgsForCall, struct {
		arg1 domain.ChatStatus
	}{arg1})
	stub := fake.UpdateChatStatusStub
	fakeReturns := fake.updateChatStatusReturns
	fake.recordInvocation("UpdateChatStatus", []interface{}{arg1})
	fake.updateChatStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) UpdateChatStatusCallCount() int {
	fake.updateChatStatusMutex.RLock()
	defer fake.updateChatStatusMutex.RUnlock()
	return len(fake.updateChatStatusArgsForCall)
}

func (fake *FakeStateManager) UpdateChatStatusCalls(stub func(domain.ChatStatus) error) {
	fake.updateChatStatusMutex.Lock()
	defer fake.updateChatStatusMutex.Unlock()
	fake.UpdateChatStatusStub = stub
}

func (fake *FakeStateManager) UpdateChatStatusArgsForCall(i int) domain.ChatStatus {
	fake.updateChatStatusMutex.RLock()
	defer fake.updateChatStatusMutex.RUnlock()
	argsForCall := fake.updateChatStatusArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) UpdateChatStatusReturns(result1 error) {
	fake.updateChatStatusMutex.Lock()
	defer fake.updateChatStatusMutex.Unlock()
	fake.UpdateChatStatusStub = nil
	fake.updateChatStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) UpdateChatStatusReturnsOnCall(i int, result1 error) {
	fake.updateChatStatusMutex.Lock()
	defer fake.updateChatStatusMutex.Unlock()
	fake.UpdateChatStatusStub = nil
	if fake.updateChatStatusReturnsOnCall == nil {
		fake.updateChatStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateChatStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) UpdateFileSearchQuery(arg1 string) {
	fake.updateFileSearchQueryMutex.Lock()
	fake.updateFileSearchQueryArgsForCall = append(fake.updateFileSearchQueryArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.UpdateFileSearchQueryStub
	fake.recordInvocation("UpdateFileSearchQuery", []interface{}{arg1})
	fake.updateFileSearchQueryMutex.Unlock()
	if stub != nil {
		fake.UpdateFileSearchQueryStub(arg1)
	}
}

func (fake *FakeStateManager) UpdateFileSearchQueryCallCount() int {
	fake.updateFileSearchQueryMutex.RLock()
	defer fake.updateFileSearchQueryMutex.RUnlock()
	return len(fake.updateFileSearchQueryArgsForCall)
}

func (fake *FakeStateManager) UpdateFileSearchQueryCalls(stub func(string)) {
	fake.updateFileSearchQueryMutex.Lock()
	defer fake.updateFileSearchQueryMutex.Unlock()
	fake.UpdateFileSearchQueryStub = stub
}

func (fake *FakeStateManager) UpdateFileSearchQueryArgsForCall(i int) string {
	fake.updateFileSearchQueryMutex.RLock()
	defer fake.updateFileSearchQueryMutex.RUnlock()
	argsForCall := fake.updateFileSearchQueryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStateManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ domain.StateManager = new(FakeStateManager)
