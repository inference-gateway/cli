// Code generated by counterfeiter. DO NOT EDIT.
package generated

import (
	"sync"

	"github.com/inference-gateway/cli/internal/domain"
	"github.com/inference-gateway/sdk"
)

type FakeStateManager struct {
	ClearFileSelectionStateStub        func()
	clearFileSelectionStateMutex       sync.RWMutex
	clearFileSelectionStateArgsForCall []struct {
	}
	CompleteCurrentToolStub        func(*domain.ToolExecutionResult) error
	completeCurrentToolMutex       sync.RWMutex
	completeCurrentToolArgsForCall []struct {
		arg1 *domain.ToolExecutionResult
	}
	completeCurrentToolReturns struct {
		result1 error
	}
	completeCurrentToolReturnsOnCall map[int]struct {
		result1 error
	}
	EndChatSessionStub        func()
	endChatSessionMutex       sync.RWMutex
	endChatSessionArgsForCall []struct {
	}
	EndToolExecutionStub        func()
	endToolExecutionMutex       sync.RWMutex
	endToolExecutionArgsForCall []struct {
	}
	FailCurrentToolStub        func(*domain.ToolExecutionResult) error
	failCurrentToolMutex       sync.RWMutex
	failCurrentToolArgsForCall []struct {
		arg1 *domain.ToolExecutionResult
	}
	failCurrentToolReturns struct {
		result1 error
	}
	failCurrentToolReturnsOnCall map[int]struct {
		result1 error
	}
	GetChatSessionStub        func() *domain.ChatSession
	getChatSessionMutex       sync.RWMutex
	getChatSessionArgsForCall []struct {
	}
	getChatSessionReturns struct {
		result1 *domain.ChatSession
	}
	getChatSessionReturnsOnCall map[int]struct {
		result1 *domain.ChatSession
	}
	GetCurrentViewStub        func() domain.ViewState
	getCurrentViewMutex       sync.RWMutex
	getCurrentViewArgsForCall []struct {
	}
	getCurrentViewReturns struct {
		result1 domain.ViewState
	}
	getCurrentViewReturnsOnCall map[int]struct {
		result1 domain.ViewState
	}
	GetDimensionsStub        func() (int, int)
	getDimensionsMutex       sync.RWMutex
	getDimensionsArgsForCall []struct {
	}
	getDimensionsReturns struct {
		result1 int
		result2 int
	}
	getDimensionsReturnsOnCall map[int]struct {
		result1 int
		result2 int
	}
	GetFileSelectionStateStub        func() *domain.FileSelectionState
	getFileSelectionStateMutex       sync.RWMutex
	getFileSelectionStateArgsForCall []struct {
	}
	getFileSelectionStateReturns struct {
		result1 *domain.FileSelectionState
	}
	getFileSelectionStateReturnsOnCall map[int]struct {
		result1 *domain.FileSelectionState
	}
	GetToolExecutionStub        func() *domain.ToolExecutionSession
	getToolExecutionMutex       sync.RWMutex
	getToolExecutionArgsForCall []struct {
	}
	getToolExecutionReturns struct {
		result1 *domain.ToolExecutionSession
	}
	getToolExecutionReturnsOnCall map[int]struct {
		result1 *domain.ToolExecutionSession
	}
	SetDimensionsStub        func(int, int)
	setDimensionsMutex       sync.RWMutex
	setDimensionsArgsForCall []struct {
		arg1 int
		arg2 int
	}
	SetFileSelectedIndexStub        func(int)
	setFileSelectedIndexMutex       sync.RWMutex
	setFileSelectedIndexArgsForCall []struct {
		arg1 int
	}
	SetupFileSelectionStub        func([]string)
	setupFileSelectionMutex       sync.RWMutex
	setupFileSelectionArgsForCall []struct {
		arg1 []string
	}
	StartChatSessionStub        func(string, string, <-chan domain.ChatEvent) error
	startChatSessionMutex       sync.RWMutex
	startChatSessionArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 <-chan domain.ChatEvent
	}
	startChatSessionReturns struct {
		result1 error
	}
	startChatSessionReturnsOnCall map[int]struct {
		result1 error
	}
	StartToolExecutionStub        func([]sdk.ChatCompletionMessageToolCall) error
	startToolExecutionMutex       sync.RWMutex
	startToolExecutionArgsForCall []struct {
		arg1 []sdk.ChatCompletionMessageToolCall
	}
	startToolExecutionReturns struct {
		result1 error
	}
	startToolExecutionReturnsOnCall map[int]struct {
		result1 error
	}
	TransitionToViewStub        func(domain.ViewState) error
	transitionToViewMutex       sync.RWMutex
	transitionToViewArgsForCall []struct {
		arg1 domain.ViewState
	}
	transitionToViewReturns struct {
		result1 error
	}
	transitionToViewReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateChatStatusStub        func(domain.ChatStatus) error
	updateChatStatusMutex       sync.RWMutex
	updateChatStatusArgsForCall []struct {
		arg1 domain.ChatStatus
	}
	updateChatStatusReturns struct {
		result1 error
	}
	updateChatStatusReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateFileSearchQueryStub        func(string)
	updateFileSearchQueryMutex       sync.RWMutex
	updateFileSearchQueryArgsForCall []struct {
		arg1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStateManager) ClearFileSelectionState() {
	fake.clearFileSelectionStateMutex.Lock()
	fake.clearFileSelectionStateArgsForCall = append(fake.clearFileSelectionStateArgsForCall, struct {
	}{})
	stub := fake.ClearFileSelectionStateStub
	fake.recordInvocation("ClearFileSelectionState", []interface{}{})
	fake.clearFileSelectionStateMutex.Unlock()
	if stub != nil {
		fake.ClearFileSelectionStateStub()
	}
}

func (fake *FakeStateManager) ClearFileSelectionStateCallCount() int {
	fake.clearFileSelectionStateMutex.RLock()
	defer fake.clearFileSelectionStateMutex.RUnlock()
	return len(fake.clearFileSelectionStateArgsForCall)
}

func (fake *FakeStateManager) ClearFileSelectionStateCalls(stub func()) {
	fake.clearFileSelectionStateMutex.Lock()
	defer fake.clearFileSelectionStateMutex.Unlock()
	fake.ClearFileSelectionStateStub = stub
}

func (fake *FakeStateManager) CompleteCurrentTool(arg1 *domain.ToolExecutionResult) error {
	fake.completeCurrentToolMutex.Lock()
	ret, specificReturn := fake.completeCurrentToolReturnsOnCall[len(fake.completeCurrentToolArgsForCall)]
	fake.completeCurrentToolArgsForCall = append(fake.completeCurrentToolArgsForCall, struct {
		arg1 *domain.ToolExecutionResult
	}{arg1})
	stub := fake.CompleteCurrentToolStub
	fakeReturns := fake.completeCurrentToolReturns
	fake.recordInvocation("CompleteCurrentTool", []interface{}{arg1})
	fake.completeCurrentToolMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) CompleteCurrentToolCallCount() int {
	fake.completeCurrentToolMutex.RLock()
	defer fake.completeCurrentToolMutex.RUnlock()
	return len(fake.completeCurrentToolArgsForCall)
}

func (fake *FakeStateManager) CompleteCurrentToolCalls(stub func(*domain.ToolExecutionResult) error) {
	fake.completeCurrentToolMutex.Lock()
	defer fake.completeCurrentToolMutex.Unlock()
	fake.CompleteCurrentToolStub = stub
}

func (fake *FakeStateManager) CompleteCurrentToolArgsForCall(i int) *domain.ToolExecutionResult {
	fake.completeCurrentToolMutex.RLock()
	defer fake.completeCurrentToolMutex.RUnlock()
	argsForCall := fake.completeCurrentToolArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) CompleteCurrentToolReturns(result1 error) {
	fake.completeCurrentToolMutex.Lock()
	defer fake.completeCurrentToolMutex.Unlock()
	fake.CompleteCurrentToolStub = nil
	fake.completeCurrentToolReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) CompleteCurrentToolReturnsOnCall(i int, result1 error) {
	fake.completeCurrentToolMutex.Lock()
	defer fake.completeCurrentToolMutex.Unlock()
	fake.CompleteCurrentToolStub = nil
	if fake.completeCurrentToolReturnsOnCall == nil {
		fake.completeCurrentToolReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.completeCurrentToolReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) EndChatSession() {
	fake.endChatSessionMutex.Lock()
	fake.endChatSessionArgsForCall = append(fake.endChatSessionArgsForCall, struct {
	}{})
	stub := fake.EndChatSessionStub
	fake.recordInvocation("EndChatSession", []interface{}{})
	fake.endChatSessionMutex.Unlock()
	if stub != nil {
		fake.EndChatSessionStub()
	}
}

func (fake *FakeStateManager) EndChatSessionCallCount() int {
	fake.endChatSessionMutex.RLock()
	defer fake.endChatSessionMutex.RUnlock()
	return len(fake.endChatSessionArgsForCall)
}

func (fake *FakeStateManager) EndChatSessionCalls(stub func()) {
	fake.endChatSessionMutex.Lock()
	defer fake.endChatSessionMutex.Unlock()
	fake.EndChatSessionStub = stub
}

func (fake *FakeStateManager) EndToolExecution() {
	fake.endToolExecutionMutex.Lock()
	fake.endToolExecutionArgsForCall = append(fake.endToolExecutionArgsForCall, struct {
	}{})
	stub := fake.EndToolExecutionStub
	fake.recordInvocation("EndToolExecution", []interface{}{})
	fake.endToolExecutionMutex.Unlock()
	if stub != nil {
		fake.EndToolExecutionStub()
	}
}

func (fake *FakeStateManager) EndToolExecutionCallCount() int {
	fake.endToolExecutionMutex.RLock()
	defer fake.endToolExecutionMutex.RUnlock()
	return len(fake.endToolExecutionArgsForCall)
}

func (fake *FakeStateManager) EndToolExecutionCalls(stub func()) {
	fake.endToolExecutionMutex.Lock()
	defer fake.endToolExecutionMutex.Unlock()
	fake.EndToolExecutionStub = stub
}

func (fake *FakeStateManager) FailCurrentTool(arg1 *domain.ToolExecutionResult) error {
	fake.failCurrentToolMutex.Lock()
	ret, specificReturn := fake.failCurrentToolReturnsOnCall[len(fake.failCurrentToolArgsForCall)]
	fake.failCurrentToolArgsForCall = append(fake.failCurrentToolArgsForCall, struct {
		arg1 *domain.ToolExecutionResult
	}{arg1})
	stub := fake.FailCurrentToolStub
	fakeReturns := fake.failCurrentToolReturns
	fake.recordInvocation("FailCurrentTool", []interface{}{arg1})
	fake.failCurrentToolMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) FailCurrentToolCallCount() int {
	fake.failCurrentToolMutex.RLock()
	defer fake.failCurrentToolMutex.RUnlock()
	return len(fake.failCurrentToolArgsForCall)
}

func (fake *FakeStateManager) FailCurrentToolCalls(stub func(*domain.ToolExecutionResult) error) {
	fake.failCurrentToolMutex.Lock()
	defer fake.failCurrentToolMutex.Unlock()
	fake.FailCurrentToolStub = stub
}

func (fake *FakeStateManager) FailCurrentToolArgsForCall(i int) *domain.ToolExecutionResult {
	fake.failCurrentToolMutex.RLock()
	defer fake.failCurrentToolMutex.RUnlock()
	argsForCall := fake.failCurrentToolArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) FailCurrentToolReturns(result1 error) {
	fake.failCurrentToolMutex.Lock()
	defer fake.failCurrentToolMutex.Unlock()
	fake.FailCurrentToolStub = nil
	fake.failCurrentToolReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) FailCurrentToolReturnsOnCall(i int, result1 error) {
	fake.failCurrentToolMutex.Lock()
	defer fake.failCurrentToolMutex.Unlock()
	fake.FailCurrentToolStub = nil
	if fake.failCurrentToolReturnsOnCall == nil {
		fake.failCurrentToolReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.failCurrentToolReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) GetChatSession() *domain.ChatSession {
	fake.getChatSessionMutex.Lock()
	ret, specificReturn := fake.getChatSessionReturnsOnCall[len(fake.getChatSessionArgsForCall)]
	fake.getChatSessionArgsForCall = append(fake.getChatSessionArgsForCall, struct {
	}{})
	stub := fake.GetChatSessionStub
	fakeReturns := fake.getChatSessionReturns
	fake.recordInvocation("GetChatSession", []interface{}{})
	fake.getChatSessionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetChatSessionCallCount() int {
	fake.getChatSessionMutex.RLock()
	defer fake.getChatSessionMutex.RUnlock()
	return len(fake.getChatSessionArgsForCall)
}

func (fake *FakeStateManager) GetChatSessionCalls(stub func() *domain.ChatSession) {
	fake.getChatSessionMutex.Lock()
	defer fake.getChatSessionMutex.Unlock()
	fake.GetChatSessionStub = stub
}

func (fake *FakeStateManager) GetChatSessionReturns(result1 *domain.ChatSession) {
	fake.getChatSessionMutex.Lock()
	defer fake.getChatSessionMutex.Unlock()
	fake.GetChatSessionStub = nil
	fake.getChatSessionReturns = struct {
		result1 *domain.ChatSession
	}{result1}
}

func (fake *FakeStateManager) GetChatSessionReturnsOnCall(i int, result1 *domain.ChatSession) {
	fake.getChatSessionMutex.Lock()
	defer fake.getChatSessionMutex.Unlock()
	fake.GetChatSessionStub = nil
	if fake.getChatSessionReturnsOnCall == nil {
		fake.getChatSessionReturnsOnCall = make(map[int]struct {
			result1 *domain.ChatSession
		})
	}
	fake.getChatSessionReturnsOnCall[i] = struct {
		result1 *domain.ChatSession
	}{result1}
}

func (fake *FakeStateManager) GetCurrentView() domain.ViewState {
	fake.getCurrentViewMutex.Lock()
	ret, specificReturn := fake.getCurrentViewReturnsOnCall[len(fake.getCurrentViewArgsForCall)]
	fake.getCurrentViewArgsForCall = append(fake.getCurrentViewArgsForCall, struct {
	}{})
	stub := fake.GetCurrentViewStub
	fakeReturns := fake.getCurrentViewReturns
	fake.recordInvocation("GetCurrentView", []interface{}{})
	fake.getCurrentViewMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetCurrentViewCallCount() int {
	fake.getCurrentViewMutex.RLock()
	defer fake.getCurrentViewMutex.RUnlock()
	return len(fake.getCurrentViewArgsForCall)
}

func (fake *FakeStateManager) GetCurrentViewCalls(stub func() domain.ViewState) {
	fake.getCurrentViewMutex.Lock()
	defer fake.getCurrentViewMutex.Unlock()
	fake.GetCurrentViewStub = stub
}

func (fake *FakeStateManager) GetCurrentViewReturns(result1 domain.ViewState) {
	fake.getCurrentViewMutex.Lock()
	defer fake.getCurrentViewMutex.Unlock()
	fake.GetCurrentViewStub = nil
	fake.getCurrentViewReturns = struct {
		result1 domain.ViewState
	}{result1}
}

func (fake *FakeStateManager) GetCurrentViewReturnsOnCall(i int, result1 domain.ViewState) {
	fake.getCurrentViewMutex.Lock()
	defer fake.getCurrentViewMutex.Unlock()
	fake.GetCurrentViewStub = nil
	if fake.getCurrentViewReturnsOnCall == nil {
		fake.getCurrentViewReturnsOnCall = make(map[int]struct {
			result1 domain.ViewState
		})
	}
	fake.getCurrentViewReturnsOnCall[i] = struct {
		result1 domain.ViewState
	}{result1}
}

func (fake *FakeStateManager) GetDimensions() (int, int) {
	fake.getDimensionsMutex.Lock()
	ret, specificReturn := fake.getDimensionsReturnsOnCall[len(fake.getDimensionsArgsForCall)]
	fake.getDimensionsArgsForCall = append(fake.getDimensionsArgsForCall, struct {
	}{})
	stub := fake.GetDimensionsStub
	fakeReturns := fake.getDimensionsReturns
	fake.recordInvocation("GetDimensions", []interface{}{})
	fake.getDimensionsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStateManager) GetDimensionsCallCount() int {
	fake.getDimensionsMutex.RLock()
	defer fake.getDimensionsMutex.RUnlock()
	return len(fake.getDimensionsArgsForCall)
}

func (fake *FakeStateManager) GetDimensionsCalls(stub func() (int, int)) {
	fake.getDimensionsMutex.Lock()
	defer fake.getDimensionsMutex.Unlock()
	fake.GetDimensionsStub = stub
}

func (fake *FakeStateManager) GetDimensionsReturns(result1 int, result2 int) {
	fake.getDimensionsMutex.Lock()
	defer fake.getDimensionsMutex.Unlock()
	fake.GetDimensionsStub = nil
	fake.getDimensionsReturns = struct {
		result1 int
		result2 int
	}{result1, result2}
}

func (fake *FakeStateManager) GetDimensionsReturnsOnCall(i int, result1 int, result2 int) {
	fake.getDimensionsMutex.Lock()
	defer fake.getDimensionsMutex.Unlock()
	fake.GetDimensionsStub = nil
	if fake.getDimensionsReturnsOnCall == nil {
		fake.getDimensionsReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
		})
	}
	fake.getDimensionsReturnsOnCall[i] = struct {
		result1 int
		result2 int
	}{result1, result2}
}

func (fake *FakeStateManager) GetFileSelectionState() *domain.FileSelectionState {
	fake.getFileSelectionStateMutex.Lock()
	ret, specificReturn := fake.getFileSelectionStateReturnsOnCall[len(fake.getFileSelectionStateArgsForCall)]
	fake.getFileSelectionStateArgsForCall = append(fake.getFileSelectionStateArgsForCall, struct {
	}{})
	stub := fake.GetFileSelectionStateStub
	fakeReturns := fake.getFileSelectionStateReturns
	fake.recordInvocation("GetFileSelectionState", []interface{}{})
	fake.getFileSelectionStateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetFileSelectionStateCallCount() int {
	fake.getFileSelectionStateMutex.RLock()
	defer fake.getFileSelectionStateMutex.RUnlock()
	return len(fake.getFileSelectionStateArgsForCall)
}

func (fake *FakeStateManager) GetFileSelectionStateCalls(stub func() *domain.FileSelectionState) {
	fake.getFileSelectionStateMutex.Lock()
	defer fake.getFileSelectionStateMutex.Unlock()
	fake.GetFileSelectionStateStub = stub
}

func (fake *FakeStateManager) GetFileSelectionStateReturns(result1 *domain.FileSelectionState) {
	fake.getFileSelectionStateMutex.Lock()
	defer fake.getFileSelectionStateMutex.Unlock()
	fake.GetFileSelectionStateStub = nil
	fake.getFileSelectionStateReturns = struct {
		result1 *domain.FileSelectionState
	}{result1}
}

func (fake *FakeStateManager) GetFileSelectionStateReturnsOnCall(i int, result1 *domain.FileSelectionState) {
	fake.getFileSelectionStateMutex.Lock()
	defer fake.getFileSelectionStateMutex.Unlock()
	fake.GetFileSelectionStateStub = nil
	if fake.getFileSelectionStateReturnsOnCall == nil {
		fake.getFileSelectionStateReturnsOnCall = make(map[int]struct {
			result1 *domain.FileSelectionState
		})
	}
	fake.getFileSelectionStateReturnsOnCall[i] = struct {
		result1 *domain.FileSelectionState
	}{result1}
}

func (fake *FakeStateManager) GetToolExecution() *domain.ToolExecutionSession {
	fake.getToolExecutionMutex.Lock()
	ret, specificReturn := fake.getToolExecutionReturnsOnCall[len(fake.getToolExecutionArgsForCall)]
	fake.getToolExecutionArgsForCall = append(fake.getToolExecutionArgsForCall, struct {
	}{})
	stub := fake.GetToolExecutionStub
	fakeReturns := fake.getToolExecutionReturns
	fake.recordInvocation("GetToolExecution", []interface{}{})
	fake.getToolExecutionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetToolExecutionCallCount() int {
	fake.getToolExecutionMutex.RLock()
	defer fake.getToolExecutionMutex.RUnlock()
	return len(fake.getToolExecutionArgsForCall)
}

func (fake *FakeStateManager) GetToolExecutionCalls(stub func() *domain.ToolExecutionSession) {
	fake.getToolExecutionMutex.Lock()
	defer fake.getToolExecutionMutex.Unlock()
	fake.GetToolExecutionStub = stub
}

func (fake *FakeStateManager) GetToolExecutionReturns(result1 *domain.ToolExecutionSession) {
	fake.getToolExecutionMutex.Lock()
	defer fake.getToolExecutionMutex.Unlock()
	fake.GetToolExecutionStub = nil
	fake.getToolExecutionReturns = struct {
		result1 *domain.ToolExecutionSession
	}{result1}
}

func (fake *FakeStateManager) GetToolExecutionReturnsOnCall(i int, result1 *domain.ToolExecutionSession) {
	fake.getToolExecutionMutex.Lock()
	defer fake.getToolExecutionMutex.Unlock()
	fake.GetToolExecutionStub = nil
	if fake.getToolExecutionReturnsOnCall == nil {
		fake.getToolExecutionReturnsOnCall = make(map[int]struct {
			result1 *domain.ToolExecutionSession
		})
	}
	fake.getToolExecutionReturnsOnCall[i] = struct {
		result1 *domain.ToolExecutionSession
	}{result1}
}

func (fake *FakeStateManager) SetDimensions(arg1 int, arg2 int) {
	fake.setDimensionsMutex.Lock()
	fake.setDimensionsArgsForCall = append(fake.setDimensionsArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.SetDimensionsStub
	fake.recordInvocation("SetDimensions", []interface{}{arg1, arg2})
	fake.setDimensionsMutex.Unlock()
	if stub != nil {
		fake.SetDimensionsStub(arg1, arg2)
	}
}

func (fake *FakeStateManager) SetDimensionsCallCount() int {
	fake.setDimensionsMutex.RLock()
	defer fake.setDimensionsMutex.RUnlock()
	return len(fake.setDimensionsArgsForCall)
}

func (fake *FakeStateManager) SetDimensionsCalls(stub func(int, int)) {
	fake.setDimensionsMutex.Lock()
	defer fake.setDimensionsMutex.Unlock()
	fake.SetDimensionsStub = stub
}

func (fake *FakeStateManager) SetDimensionsArgsForCall(i int) (int, int) {
	fake.setDimensionsMutex.RLock()
	defer fake.setDimensionsMutex.RUnlock()
	argsForCall := fake.setDimensionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStateManager) SetFileSelectedIndex(arg1 int) {
	fake.setFileSelectedIndexMutex.Lock()
	fake.setFileSelectedIndexArgsForCall = append(fake.setFileSelectedIndexArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.SetFileSelectedIndexStub
	fake.recordInvocation("SetFileSelectedIndex", []interface{}{arg1})
	fake.setFileSelectedIndexMutex.Unlock()
	if stub != nil {
		fake.SetFileSelectedIndexStub(arg1)
	}
}

func (fake *FakeStateManager) SetFileSelectedIndexCallCount() int {
	fake.setFileSelectedIndexMutex.RLock()
	defer fake.setFileSelectedIndexMutex.RUnlock()
	return len(fake.setFileSelectedIndexArgsForCall)
}

func (fake *FakeStateManager) SetFileSelectedIndexCalls(stub func(int)) {
	fake.setFileSelectedIndexMutex.Lock()
	defer fake.setFileSelectedIndexMutex.Unlock()
	fake.SetFileSelectedIndexStub = stub
}

func (fake *FakeStateManager) SetFileSelectedIndexArgsForCall(i int) int {
	fake.setFileSelectedIndexMutex.RLock()
	defer fake.setFileSelectedIndexMutex.RUnlock()
	argsForCall := fake.setFileSelectedIndexArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) SetupFileSelection(arg1 []string) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setupFileSelectionMutex.Lock()
	fake.setupFileSelectionArgsForCall = append(fake.setupFileSelectionArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.SetupFileSelectionStub
	fake.recordInvocation("SetupFileSelection", []interface{}{arg1Copy})
	fake.setupFileSelectionMutex.Unlock()
	if stub != nil {
		fake.SetupFileSelectionStub(arg1)
	}
}

func (fake *FakeStateManager) SetupFileSelectionCallCount() int {
	fake.setupFileSelectionMutex.RLock()
	defer fake.setupFileSelectionMutex.RUnlock()
	return len(fake.setupFileSelectionArgsForCall)
}

func (fake *FakeStateManager) SetupFileSelectionCalls(stub func([]string)) {
	fake.setupFileSelectionMutex.Lock()
	defer fake.setupFileSelectionMutex.Unlock()
	fake.SetupFileSelectionStub = stub
}

func (fake *FakeStateManager) SetupFileSelectionArgsForCall(i int) []string {
	fake.setupFileSelectionMutex.RLock()
	defer fake.setupFileSelectionMutex.RUnlock()
	argsForCall := fake.setupFileSelectionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) StartChatSession(arg1 string, arg2 string, arg3 <-chan domain.ChatEvent) error {
	fake.startChatSessionMutex.Lock()
	ret, specificReturn := fake.startChatSessionReturnsOnCall[len(fake.startChatSessionArgsForCall)]
	fake.startChatSessionArgsForCall = append(fake.startChatSessionArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 <-chan domain.ChatEvent
	}{arg1, arg2, arg3})
	stub := fake.StartChatSessionStub
	fakeReturns := fake.startChatSessionReturns
	fake.recordInvocation("StartChatSession", []interface{}{arg1, arg2, arg3})
	fake.startChatSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) StartChatSessionCallCount() int {
	fake.startChatSessionMutex.RLock()
	defer fake.startChatSessionMutex.RUnlock()
	return len(fake.startChatSessionArgsForCall)
}

func (fake *FakeStateManager) StartChatSessionCalls(stub func(string, string, <-chan domain.ChatEvent) error) {
	fake.startChatSessionMutex.Lock()
	defer fake.startChatSessionMutex.Unlock()
	fake.StartChatSessionStub = stub
}

func (fake *FakeStateManager) StartChatSessionArgsForCall(i int) (string, string, <-chan domain.ChatEvent) {
	fake.startChatSessionMutex.RLock()
	defer fake.startChatSessionMutex.RUnlock()
	argsForCall := fake.startChatSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStateManager) StartChatSessionReturns(result1 error) {
	fake.startChatSessionMutex.Lock()
	defer fake.startChatSessionMutex.Unlock()
	fake.StartChatSessionStub = nil
	fake.startChatSessionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) StartChatSessionReturnsOnCall(i int, result1 error) {
	fake.startChatSessionMutex.Lock()
	defer fake.startChatSessionMutex.Unlock()
	fake.StartChatSessionStub = nil
	if fake.startChatSessionReturnsOnCall == nil {
		fake.startChatSessionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startChatSessionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) StartToolExecution(arg1 []sdk.ChatCompletionMessageToolCall) error {
	var arg1Copy []sdk.ChatCompletionMessageToolCall
	if arg1 != nil {
		arg1Copy = make([]sdk.ChatCompletionMessageToolCall, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.startToolExecutionMutex.Lock()
	ret, specificReturn := fake.startToolExecutionReturnsOnCall[len(fake.startToolExecutionArgsForCall)]
	fake.startToolExecutionArgsForCall = append(fake.startToolExecutionArgsForCall, struct {
		arg1 []sdk.ChatCompletionMessageToolCall
	}{arg1Copy})
	stub := fake.StartToolExecutionStub
	fakeReturns := fake.startToolExecutionReturns
	fake.recordInvocation("StartToolExecution", []interface{}{arg1Copy})
	fake.startToolExecutionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) StartToolExecutionCallCount() int {
	fake.startToolExecutionMutex.RLock()
	defer fake.startToolExecutionMutex.RUnlock()
	return len(fake.startToolExecutionArgsForCall)
}

func (fake *FakeStateManager) StartToolExecutionCalls(stub func([]sdk.ChatCompletionMessageToolCall) error) {
	fake.startToolExecutionMutex.Lock()
	defer fake.startToolExecutionMutex.Unlock()
	fake.StartToolExecutionStub = stub
}

func (fake *FakeStateManager) StartToolExecutionArgsForCall(i int) []sdk.ChatCompletionMessageToolCall {
	fake.startToolExecutionMutex.RLock()
	defer fake.startToolExecutionMutex.RUnlock()
	argsForCall := fake.startToolExecutionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) StartToolExecutionReturns(result1 error) {
	fake.startToolExecutionMutex.Lock()
	defer fake.startToolExecutionMutex.Unlock()
	fake.StartToolExecutionStub = nil
	fake.startToolExecutionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) StartToolExecutionReturnsOnCall(i int, result1 error) {
	fake.startToolExecutionMutex.Lock()
	defer fake.startToolExecutionMutex.Unlock()
	fake.StartToolExecutionStub = nil
	if fake.startToolExecutionReturnsOnCall == nil {
		fake.startToolExecutionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startToolExecutionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) TransitionToView(arg1 domain.ViewState) error {
	fake.transitionToViewMutex.Lock()
	ret, specificReturn := fake.transitionToViewReturnsOnCall[len(fake.transitionToViewArgsForCall)]
	fake.transitionToViewArgsForCall = append(fake.transitionToViewArgsForCall, struct {
		arg1 domain.ViewState
	}{arg1})
	stub := fake.TransitionToViewStub
	fakeReturns := fake.transitionToViewReturns
	fake.recordInvocation("TransitionToView", []interface{}{arg1})
	fake.transitionToViewMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) TransitionToViewCallCount() int {
	fake.transitionToViewMutex.RLock()
	defer fake.transitionToViewMutex.RUnlock()
	return len(fake.transitionToViewArgsForCall)
}

func (fake *FakeStateManager) TransitionToViewCalls(stub func(domain.ViewState) error) {
	fake.transitionToViewMutex.Lock()
	defer fake.transitionToViewMutex.Unlock()
	fake.TransitionToViewStub = stub
}

func (fake *FakeStateManager) TransitionToViewArgsForCall(i int) domain.ViewState {
	fake.transitionToViewMutex.RLock()
	defer fake.transitionToViewMutex.RUnlock()
	argsForCall := fake.transitionToViewArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) TransitionToViewReturns(result1 error) {
	fake.transitionToViewMutex.Lock()
	defer fake.transitionToViewMutex.Unlock()
	fake.TransitionToViewStub = nil
	fake.transitionToViewReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) TransitionToViewReturnsOnCall(i int, result1 error) {
	fake.transitionToViewMutex.Lock()
	defer fake.transitionToViewMutex.Unlock()
	fake.TransitionToViewStub = nil
	if fake.transitionToViewReturnsOnCall == nil {
		fake.transitionToViewReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.transitionToViewReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) UpdateChatStatus(arg1 domain.ChatStatus) error {
	fake.updateChatStatusMutex.Lock()
	ret, specificReturn := fake.updateChatStatusReturnsOnCall[len(fake.updateChatStatusArgsForCall)]
	fake.updateChatStatusArgsForCall = append(fake.updateChatStatusArgsForCall, struct {
		arg1 domain.ChatStatus
	}{arg1})
	stub := fake.UpdateChatStatusStub
	fakeReturns := fake.updateChatStatusReturns
	fake.recordInvocation("UpdateChatStatus", []interface{}{arg1})
	fake.updateChatStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) UpdateChatStatusCallCount() int {
	fake.updateChatStatusMutex.RLock()
	defer fake.updateChatStatusMutex.RUnlock()
	return len(fake.updateChatStatusArgsForCall)
}

func (fake *FakeStateManager) UpdateChatStatusCalls(stub func(domain.ChatStatus) error) {
	fake.updateChatStatusMutex.Lock()
	defer fake.updateChatStatusMutex.Unlock()
	fake.UpdateChatStatusStub = stub
}

func (fake *FakeStateManager) UpdateChatStatusArgsForCall(i int) domain.ChatStatus {
	fake.updateChatStatusMutex.RLock()
	defer fake.updateChatStatusMutex.RUnlock()
	argsForCall := fake.updateChatStatusArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) UpdateChatStatusReturns(result1 error) {
	fake.updateChatStatusMutex.Lock()
	defer fake.updateChatStatusMutex.Unlock()
	fake.UpdateChatStatusStub = nil
	fake.updateChatStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) UpdateChatStatusReturnsOnCall(i int, result1 error) {
	fake.updateChatStatusMutex.Lock()
	defer fake.updateChatStatusMutex.Unlock()
	fake.UpdateChatStatusStub = nil
	if fake.updateChatStatusReturnsOnCall == nil {
		fake.updateChatStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateChatStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) UpdateFileSearchQuery(arg1 string) {
	fake.updateFileSearchQueryMutex.Lock()
	fake.updateFileSearchQueryArgsForCall = append(fake.updateFileSearchQueryArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.UpdateFileSearchQueryStub
	fake.recordInvocation("UpdateFileSearchQuery", []interface{}{arg1})
	fake.updateFileSearchQueryMutex.Unlock()
	if stub != nil {
		fake.UpdateFileSearchQueryStub(arg1)
	}
}

func (fake *FakeStateManager) UpdateFileSearchQueryCallCount() int {
	fake.updateFileSearchQueryMutex.RLock()
	defer fake.updateFileSearchQueryMutex.RUnlock()
	return len(fake.updateFileSearchQueryArgsForCall)
}

func (fake *FakeStateManager) UpdateFileSearchQueryCalls(stub func(string)) {
	fake.updateFileSearchQueryMutex.Lock()
	defer fake.updateFileSearchQueryMutex.Unlock()
	fake.UpdateFileSearchQueryStub = stub
}

func (fake *FakeStateManager) UpdateFileSearchQueryArgsForCall(i int) string {
	fake.updateFileSearchQueryMutex.RLock()
	defer fake.updateFileSearchQueryMutex.RUnlock()
	argsForCall := fake.updateFileSearchQueryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStateManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ domain.StateManager = new(FakeStateManager)
