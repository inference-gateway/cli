// Code generated by counterfeiter. DO NOT EDIT.
package generated

import (
	"sync"

	"github.com/inference-gateway/cli/internal/domain"
	"github.com/inference-gateway/sdk"
)

type FakeStateManager struct {
	AreAllAgentsReadyStub        func() bool
	areAllAgentsReadyMutex       sync.RWMutex
	areAllAgentsReadyArgsForCall []struct {
	}
	areAllAgentsReadyReturns struct {
		result1 bool
	}
	areAllAgentsReadyReturnsOnCall map[int]struct {
		result1 bool
	}
	ClearAgentReadinessStub        func()
	clearAgentReadinessMutex       sync.RWMutex
	clearAgentReadinessArgsForCall []struct {
	}
	ClearApprovalUIStateStub        func()
	clearApprovalUIStateMutex       sync.RWMutex
	clearApprovalUIStateArgsForCall []struct {
	}
	ClearFileSelectionStateStub        func()
	clearFileSelectionStateMutex       sync.RWMutex
	clearFileSelectionStateArgsForCall []struct {
	}
	CompleteCurrentToolStub        func(*domain.ToolExecutionResult) error
	completeCurrentToolMutex       sync.RWMutex
	completeCurrentToolArgsForCall []struct {
		arg1 *domain.ToolExecutionResult
	}
	completeCurrentToolReturns struct {
		result1 error
	}
	completeCurrentToolReturnsOnCall map[int]struct {
		result1 error
	}
	CycleAgentModeStub        func() domain.AgentMode
	cycleAgentModeMutex       sync.RWMutex
	cycleAgentModeArgsForCall []struct {
	}
	cycleAgentModeReturns struct {
		result1 domain.AgentMode
	}
	cycleAgentModeReturnsOnCall map[int]struct {
		result1 domain.AgentMode
	}
	EndChatSessionStub        func()
	endChatSessionMutex       sync.RWMutex
	endChatSessionArgsForCall []struct {
	}
	EndToolExecutionStub        func()
	endToolExecutionMutex       sync.RWMutex
	endToolExecutionArgsForCall []struct {
	}
	FailCurrentToolStub        func(*domain.ToolExecutionResult) error
	failCurrentToolMutex       sync.RWMutex
	failCurrentToolArgsForCall []struct {
		arg1 *domain.ToolExecutionResult
	}
	failCurrentToolReturns struct {
		result1 error
	}
	failCurrentToolReturnsOnCall map[int]struct {
		result1 error
	}
	GetAgentModeStub        func() domain.AgentMode
	getAgentModeMutex       sync.RWMutex
	getAgentModeArgsForCall []struct {
	}
	getAgentModeReturns struct {
		result1 domain.AgentMode
	}
	getAgentModeReturnsOnCall map[int]struct {
		result1 domain.AgentMode
	}
	GetAgentReadinessStub        func() *domain.AgentReadinessState
	getAgentReadinessMutex       sync.RWMutex
	getAgentReadinessArgsForCall []struct {
	}
	getAgentReadinessReturns struct {
		result1 *domain.AgentReadinessState
	}
	getAgentReadinessReturnsOnCall map[int]struct {
		result1 *domain.AgentReadinessState
	}
	GetApprovalUIStateStub        func() *domain.ApprovalUIState
	getApprovalUIStateMutex       sync.RWMutex
	getApprovalUIStateArgsForCall []struct {
	}
	getApprovalUIStateReturns struct {
		result1 *domain.ApprovalUIState
	}
	getApprovalUIStateReturnsOnCall map[int]struct {
		result1 *domain.ApprovalUIState
	}
	GetChatSessionStub        func() *domain.ChatSession
	getChatSessionMutex       sync.RWMutex
	getChatSessionArgsForCall []struct {
	}
	getChatSessionReturns struct {
		result1 *domain.ChatSession
	}
	getChatSessionReturnsOnCall map[int]struct {
		result1 *domain.ChatSession
	}
	GetCurrentViewStub        func() domain.ViewState
	getCurrentViewMutex       sync.RWMutex
	getCurrentViewArgsForCall []struct {
	}
	getCurrentViewReturns struct {
		result1 domain.ViewState
	}
	getCurrentViewReturnsOnCall map[int]struct {
		result1 domain.ViewState
	}
	GetDimensionsStub        func() (int, int)
	getDimensionsMutex       sync.RWMutex
	getDimensionsArgsForCall []struct {
	}
	getDimensionsReturns struct {
		result1 int
		result2 int
	}
	getDimensionsReturnsOnCall map[int]struct {
		result1 int
		result2 int
	}
	GetFileSelectionStateStub        func() *domain.FileSelectionState
	getFileSelectionStateMutex       sync.RWMutex
	getFileSelectionStateArgsForCall []struct {
	}
	getFileSelectionStateReturns struct {
		result1 *domain.FileSelectionState
	}
	getFileSelectionStateReturnsOnCall map[int]struct {
		result1 *domain.FileSelectionState
	}
	GetTodosStub        func() []domain.TodoItem
	getTodosMutex       sync.RWMutex
	getTodosArgsForCall []struct {
	}
	getTodosReturns struct {
		result1 []domain.TodoItem
	}
	getTodosReturnsOnCall map[int]struct {
		result1 []domain.TodoItem
	}
	GetToolExecutionStub        func() *domain.ToolExecutionSession
	getToolExecutionMutex       sync.RWMutex
	getToolExecutionArgsForCall []struct {
	}
	getToolExecutionReturns struct {
		result1 *domain.ToolExecutionSession
	}
	getToolExecutionReturnsOnCall map[int]struct {
		result1 *domain.ToolExecutionSession
	}
	InitializeAgentReadinessStub        func(int)
	initializeAgentReadinessMutex       sync.RWMutex
	initializeAgentReadinessArgsForCall []struct {
		arg1 int
	}
	IsAgentBusyStub        func() bool
	isAgentBusyMutex       sync.RWMutex
	isAgentBusyArgsForCall []struct {
	}
	isAgentBusyReturns struct {
		result1 bool
	}
	isAgentBusyReturnsOnCall map[int]struct {
		result1 bool
	}
	SetAgentErrorStub        func(string, error)
	setAgentErrorMutex       sync.RWMutex
	setAgentErrorArgsForCall []struct {
		arg1 string
		arg2 error
	}
	SetAgentModeStub        func(domain.AgentMode)
	setAgentModeMutex       sync.RWMutex
	setAgentModeArgsForCall []struct {
		arg1 domain.AgentMode
	}
	SetApprovalSelectedIndexStub        func(int)
	setApprovalSelectedIndexMutex       sync.RWMutex
	setApprovalSelectedIndexArgsForCall []struct {
		arg1 int
	}
	SetChatPendingStub        func()
	setChatPendingMutex       sync.RWMutex
	setChatPendingArgsForCall []struct {
	}
	SetDimensionsStub        func(int, int)
	setDimensionsMutex       sync.RWMutex
	setDimensionsArgsForCall []struct {
		arg1 int
		arg2 int
	}
	SetFileSelectedIndexStub        func(int)
	setFileSelectedIndexMutex       sync.RWMutex
	setFileSelectedIndexArgsForCall []struct {
		arg1 int
	}
	SetTodosStub        func([]domain.TodoItem)
	setTodosMutex       sync.RWMutex
	setTodosArgsForCall []struct {
		arg1 []domain.TodoItem
	}
	SetupApprovalUIStateStub        func(*sdk.ChatCompletionMessageToolCall, chan domain.ApprovalAction)
	setupApprovalUIStateMutex       sync.RWMutex
	setupApprovalUIStateArgsForCall []struct {
		arg1 *sdk.ChatCompletionMessageToolCall
		arg2 chan domain.ApprovalAction
	}
	SetupFileSelectionStub        func([]string)
	setupFileSelectionMutex       sync.RWMutex
	setupFileSelectionArgsForCall []struct {
		arg1 []string
	}
	StartChatSessionStub        func(string, string, <-chan domain.ChatEvent) error
	startChatSessionMutex       sync.RWMutex
	startChatSessionArgsForCall []struct {
		arg1 string
		arg2 string
		arg3 <-chan domain.ChatEvent
	}
	startChatSessionReturns struct {
		result1 error
	}
	startChatSessionReturnsOnCall map[int]struct {
		result1 error
	}
	StartToolExecutionStub        func([]sdk.ChatCompletionMessageToolCall) error
	startToolExecutionMutex       sync.RWMutex
	startToolExecutionArgsForCall []struct {
		arg1 []sdk.ChatCompletionMessageToolCall
	}
	startToolExecutionReturns struct {
		result1 error
	}
	startToolExecutionReturnsOnCall map[int]struct {
		result1 error
	}
	TransitionToViewStub        func(domain.ViewState) error
	transitionToViewMutex       sync.RWMutex
	transitionToViewArgsForCall []struct {
		arg1 domain.ViewState
	}
	transitionToViewReturns struct {
		result1 error
	}
	transitionToViewReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateAgentStatusStub        func(string, domain.AgentState, string, string, string)
	updateAgentStatusMutex       sync.RWMutex
	updateAgentStatusArgsForCall []struct {
		arg1 string
		arg2 domain.AgentState
		arg3 string
		arg4 string
		arg5 string
	}
	UpdateChatStatusStub        func(domain.ChatStatus) error
	updateChatStatusMutex       sync.RWMutex
	updateChatStatusArgsForCall []struct {
		arg1 domain.ChatStatus
	}
	updateChatStatusReturns struct {
		result1 error
	}
	updateChatStatusReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateFileSearchQueryStub        func(string)
	updateFileSearchQueryMutex       sync.RWMutex
	updateFileSearchQueryArgsForCall []struct {
		arg1 string
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStateManager) AreAllAgentsReady() bool {
	fake.areAllAgentsReadyMutex.Lock()
	ret, specificReturn := fake.areAllAgentsReadyReturnsOnCall[len(fake.areAllAgentsReadyArgsForCall)]
	fake.areAllAgentsReadyArgsForCall = append(fake.areAllAgentsReadyArgsForCall, struct {
	}{})
	stub := fake.AreAllAgentsReadyStub
	fakeReturns := fake.areAllAgentsReadyReturns
	fake.recordInvocation("AreAllAgentsReady", []interface{}{})
	fake.areAllAgentsReadyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) AreAllAgentsReadyCallCount() int {
	fake.areAllAgentsReadyMutex.RLock()
	defer fake.areAllAgentsReadyMutex.RUnlock()
	return len(fake.areAllAgentsReadyArgsForCall)
}

func (fake *FakeStateManager) AreAllAgentsReadyCalls(stub func() bool) {
	fake.areAllAgentsReadyMutex.Lock()
	defer fake.areAllAgentsReadyMutex.Unlock()
	fake.AreAllAgentsReadyStub = stub
}

func (fake *FakeStateManager) AreAllAgentsReadyReturns(result1 bool) {
	fake.areAllAgentsReadyMutex.Lock()
	defer fake.areAllAgentsReadyMutex.Unlock()
	fake.AreAllAgentsReadyStub = nil
	fake.areAllAgentsReadyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStateManager) AreAllAgentsReadyReturnsOnCall(i int, result1 bool) {
	fake.areAllAgentsReadyMutex.Lock()
	defer fake.areAllAgentsReadyMutex.Unlock()
	fake.AreAllAgentsReadyStub = nil
	if fake.areAllAgentsReadyReturnsOnCall == nil {
		fake.areAllAgentsReadyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.areAllAgentsReadyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStateManager) ClearAgentReadiness() {
	fake.clearAgentReadinessMutex.Lock()
	fake.clearAgentReadinessArgsForCall = append(fake.clearAgentReadinessArgsForCall, struct {
	}{})
	stub := fake.ClearAgentReadinessStub
	fake.recordInvocation("ClearAgentReadiness", []interface{}{})
	fake.clearAgentReadinessMutex.Unlock()
	if stub != nil {
		fake.ClearAgentReadinessStub()
	}
}

func (fake *FakeStateManager) ClearAgentReadinessCallCount() int {
	fake.clearAgentReadinessMutex.RLock()
	defer fake.clearAgentReadinessMutex.RUnlock()
	return len(fake.clearAgentReadinessArgsForCall)
}

func (fake *FakeStateManager) ClearAgentReadinessCalls(stub func()) {
	fake.clearAgentReadinessMutex.Lock()
	defer fake.clearAgentReadinessMutex.Unlock()
	fake.ClearAgentReadinessStub = stub
}

func (fake *FakeStateManager) ClearApprovalUIState() {
	fake.clearApprovalUIStateMutex.Lock()
	fake.clearApprovalUIStateArgsForCall = append(fake.clearApprovalUIStateArgsForCall, struct {
	}{})
	stub := fake.ClearApprovalUIStateStub
	fake.recordInvocation("ClearApprovalUIState", []interface{}{})
	fake.clearApprovalUIStateMutex.Unlock()
	if stub != nil {
		fake.ClearApprovalUIStateStub()
	}
}

func (fake *FakeStateManager) ClearApprovalUIStateCallCount() int {
	fake.clearApprovalUIStateMutex.RLock()
	defer fake.clearApprovalUIStateMutex.RUnlock()
	return len(fake.clearApprovalUIStateArgsForCall)
}

func (fake *FakeStateManager) ClearApprovalUIStateCalls(stub func()) {
	fake.clearApprovalUIStateMutex.Lock()
	defer fake.clearApprovalUIStateMutex.Unlock()
	fake.ClearApprovalUIStateStub = stub
}

func (fake *FakeStateManager) ClearFileSelectionState() {
	fake.clearFileSelectionStateMutex.Lock()
	fake.clearFileSelectionStateArgsForCall = append(fake.clearFileSelectionStateArgsForCall, struct {
	}{})
	stub := fake.ClearFileSelectionStateStub
	fake.recordInvocation("ClearFileSelectionState", []interface{}{})
	fake.clearFileSelectionStateMutex.Unlock()
	if stub != nil {
		fake.ClearFileSelectionStateStub()
	}
}

func (fake *FakeStateManager) ClearFileSelectionStateCallCount() int {
	fake.clearFileSelectionStateMutex.RLock()
	defer fake.clearFileSelectionStateMutex.RUnlock()
	return len(fake.clearFileSelectionStateArgsForCall)
}

func (fake *FakeStateManager) ClearFileSelectionStateCalls(stub func()) {
	fake.clearFileSelectionStateMutex.Lock()
	defer fake.clearFileSelectionStateMutex.Unlock()
	fake.ClearFileSelectionStateStub = stub
}

func (fake *FakeStateManager) CompleteCurrentTool(arg1 *domain.ToolExecutionResult) error {
	fake.completeCurrentToolMutex.Lock()
	ret, specificReturn := fake.completeCurrentToolReturnsOnCall[len(fake.completeCurrentToolArgsForCall)]
	fake.completeCurrentToolArgsForCall = append(fake.completeCurrentToolArgsForCall, struct {
		arg1 *domain.ToolExecutionResult
	}{arg1})
	stub := fake.CompleteCurrentToolStub
	fakeReturns := fake.completeCurrentToolReturns
	fake.recordInvocation("CompleteCurrentTool", []interface{}{arg1})
	fake.completeCurrentToolMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) CompleteCurrentToolCallCount() int {
	fake.completeCurrentToolMutex.RLock()
	defer fake.completeCurrentToolMutex.RUnlock()
	return len(fake.completeCurrentToolArgsForCall)
}

func (fake *FakeStateManager) CompleteCurrentToolCalls(stub func(*domain.ToolExecutionResult) error) {
	fake.completeCurrentToolMutex.Lock()
	defer fake.completeCurrentToolMutex.Unlock()
	fake.CompleteCurrentToolStub = stub
}

func (fake *FakeStateManager) CompleteCurrentToolArgsForCall(i int) *domain.ToolExecutionResult {
	fake.completeCurrentToolMutex.RLock()
	defer fake.completeCurrentToolMutex.RUnlock()
	argsForCall := fake.completeCurrentToolArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) CompleteCurrentToolReturns(result1 error) {
	fake.completeCurrentToolMutex.Lock()
	defer fake.completeCurrentToolMutex.Unlock()
	fake.CompleteCurrentToolStub = nil
	fake.completeCurrentToolReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) CompleteCurrentToolReturnsOnCall(i int, result1 error) {
	fake.completeCurrentToolMutex.Lock()
	defer fake.completeCurrentToolMutex.Unlock()
	fake.CompleteCurrentToolStub = nil
	if fake.completeCurrentToolReturnsOnCall == nil {
		fake.completeCurrentToolReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.completeCurrentToolReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) CycleAgentMode() domain.AgentMode {
	fake.cycleAgentModeMutex.Lock()
	ret, specificReturn := fake.cycleAgentModeReturnsOnCall[len(fake.cycleAgentModeArgsForCall)]
	fake.cycleAgentModeArgsForCall = append(fake.cycleAgentModeArgsForCall, struct {
	}{})
	stub := fake.CycleAgentModeStub
	fakeReturns := fake.cycleAgentModeReturns
	fake.recordInvocation("CycleAgentMode", []interface{}{})
	fake.cycleAgentModeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) CycleAgentModeCallCount() int {
	fake.cycleAgentModeMutex.RLock()
	defer fake.cycleAgentModeMutex.RUnlock()
	return len(fake.cycleAgentModeArgsForCall)
}

func (fake *FakeStateManager) CycleAgentModeCalls(stub func() domain.AgentMode) {
	fake.cycleAgentModeMutex.Lock()
	defer fake.cycleAgentModeMutex.Unlock()
	fake.CycleAgentModeStub = stub
}

func (fake *FakeStateManager) CycleAgentModeReturns(result1 domain.AgentMode) {
	fake.cycleAgentModeMutex.Lock()
	defer fake.cycleAgentModeMutex.Unlock()
	fake.CycleAgentModeStub = nil
	fake.cycleAgentModeReturns = struct {
		result1 domain.AgentMode
	}{result1}
}

func (fake *FakeStateManager) CycleAgentModeReturnsOnCall(i int, result1 domain.AgentMode) {
	fake.cycleAgentModeMutex.Lock()
	defer fake.cycleAgentModeMutex.Unlock()
	fake.CycleAgentModeStub = nil
	if fake.cycleAgentModeReturnsOnCall == nil {
		fake.cycleAgentModeReturnsOnCall = make(map[int]struct {
			result1 domain.AgentMode
		})
	}
	fake.cycleAgentModeReturnsOnCall[i] = struct {
		result1 domain.AgentMode
	}{result1}
}

func (fake *FakeStateManager) EndChatSession() {
	fake.endChatSessionMutex.Lock()
	fake.endChatSessionArgsForCall = append(fake.endChatSessionArgsForCall, struct {
	}{})
	stub := fake.EndChatSessionStub
	fake.recordInvocation("EndChatSession", []interface{}{})
	fake.endChatSessionMutex.Unlock()
	if stub != nil {
		fake.EndChatSessionStub()
	}
}

func (fake *FakeStateManager) EndChatSessionCallCount() int {
	fake.endChatSessionMutex.RLock()
	defer fake.endChatSessionMutex.RUnlock()
	return len(fake.endChatSessionArgsForCall)
}

func (fake *FakeStateManager) EndChatSessionCalls(stub func()) {
	fake.endChatSessionMutex.Lock()
	defer fake.endChatSessionMutex.Unlock()
	fake.EndChatSessionStub = stub
}

func (fake *FakeStateManager) EndToolExecution() {
	fake.endToolExecutionMutex.Lock()
	fake.endToolExecutionArgsForCall = append(fake.endToolExecutionArgsForCall, struct {
	}{})
	stub := fake.EndToolExecutionStub
	fake.recordInvocation("EndToolExecution", []interface{}{})
	fake.endToolExecutionMutex.Unlock()
	if stub != nil {
		fake.EndToolExecutionStub()
	}
}

func (fake *FakeStateManager) EndToolExecutionCallCount() int {
	fake.endToolExecutionMutex.RLock()
	defer fake.endToolExecutionMutex.RUnlock()
	return len(fake.endToolExecutionArgsForCall)
}

func (fake *FakeStateManager) EndToolExecutionCalls(stub func()) {
	fake.endToolExecutionMutex.Lock()
	defer fake.endToolExecutionMutex.Unlock()
	fake.EndToolExecutionStub = stub
}

func (fake *FakeStateManager) FailCurrentTool(arg1 *domain.ToolExecutionResult) error {
	fake.failCurrentToolMutex.Lock()
	ret, specificReturn := fake.failCurrentToolReturnsOnCall[len(fake.failCurrentToolArgsForCall)]
	fake.failCurrentToolArgsForCall = append(fake.failCurrentToolArgsForCall, struct {
		arg1 *domain.ToolExecutionResult
	}{arg1})
	stub := fake.FailCurrentToolStub
	fakeReturns := fake.failCurrentToolReturns
	fake.recordInvocation("FailCurrentTool", []interface{}{arg1})
	fake.failCurrentToolMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) FailCurrentToolCallCount() int {
	fake.failCurrentToolMutex.RLock()
	defer fake.failCurrentToolMutex.RUnlock()
	return len(fake.failCurrentToolArgsForCall)
}

func (fake *FakeStateManager) FailCurrentToolCalls(stub func(*domain.ToolExecutionResult) error) {
	fake.failCurrentToolMutex.Lock()
	defer fake.failCurrentToolMutex.Unlock()
	fake.FailCurrentToolStub = stub
}

func (fake *FakeStateManager) FailCurrentToolArgsForCall(i int) *domain.ToolExecutionResult {
	fake.failCurrentToolMutex.RLock()
	defer fake.failCurrentToolMutex.RUnlock()
	argsForCall := fake.failCurrentToolArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) FailCurrentToolReturns(result1 error) {
	fake.failCurrentToolMutex.Lock()
	defer fake.failCurrentToolMutex.Unlock()
	fake.FailCurrentToolStub = nil
	fake.failCurrentToolReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) FailCurrentToolReturnsOnCall(i int, result1 error) {
	fake.failCurrentToolMutex.Lock()
	defer fake.failCurrentToolMutex.Unlock()
	fake.FailCurrentToolStub = nil
	if fake.failCurrentToolReturnsOnCall == nil {
		fake.failCurrentToolReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.failCurrentToolReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) GetAgentMode() domain.AgentMode {
	fake.getAgentModeMutex.Lock()
	ret, specificReturn := fake.getAgentModeReturnsOnCall[len(fake.getAgentModeArgsForCall)]
	fake.getAgentModeArgsForCall = append(fake.getAgentModeArgsForCall, struct {
	}{})
	stub := fake.GetAgentModeStub
	fakeReturns := fake.getAgentModeReturns
	fake.recordInvocation("GetAgentMode", []interface{}{})
	fake.getAgentModeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetAgentModeCallCount() int {
	fake.getAgentModeMutex.RLock()
	defer fake.getAgentModeMutex.RUnlock()
	return len(fake.getAgentModeArgsForCall)
}

func (fake *FakeStateManager) GetAgentModeCalls(stub func() domain.AgentMode) {
	fake.getAgentModeMutex.Lock()
	defer fake.getAgentModeMutex.Unlock()
	fake.GetAgentModeStub = stub
}

func (fake *FakeStateManager) GetAgentModeReturns(result1 domain.AgentMode) {
	fake.getAgentModeMutex.Lock()
	defer fake.getAgentModeMutex.Unlock()
	fake.GetAgentModeStub = nil
	fake.getAgentModeReturns = struct {
		result1 domain.AgentMode
	}{result1}
}

func (fake *FakeStateManager) GetAgentModeReturnsOnCall(i int, result1 domain.AgentMode) {
	fake.getAgentModeMutex.Lock()
	defer fake.getAgentModeMutex.Unlock()
	fake.GetAgentModeStub = nil
	if fake.getAgentModeReturnsOnCall == nil {
		fake.getAgentModeReturnsOnCall = make(map[int]struct {
			result1 domain.AgentMode
		})
	}
	fake.getAgentModeReturnsOnCall[i] = struct {
		result1 domain.AgentMode
	}{result1}
}

func (fake *FakeStateManager) GetAgentReadiness() *domain.AgentReadinessState {
	fake.getAgentReadinessMutex.Lock()
	ret, specificReturn := fake.getAgentReadinessReturnsOnCall[len(fake.getAgentReadinessArgsForCall)]
	fake.getAgentReadinessArgsForCall = append(fake.getAgentReadinessArgsForCall, struct {
	}{})
	stub := fake.GetAgentReadinessStub
	fakeReturns := fake.getAgentReadinessReturns
	fake.recordInvocation("GetAgentReadiness", []interface{}{})
	fake.getAgentReadinessMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetAgentReadinessCallCount() int {
	fake.getAgentReadinessMutex.RLock()
	defer fake.getAgentReadinessMutex.RUnlock()
	return len(fake.getAgentReadinessArgsForCall)
}

func (fake *FakeStateManager) GetAgentReadinessCalls(stub func() *domain.AgentReadinessState) {
	fake.getAgentReadinessMutex.Lock()
	defer fake.getAgentReadinessMutex.Unlock()
	fake.GetAgentReadinessStub = stub
}

func (fake *FakeStateManager) GetAgentReadinessReturns(result1 *domain.AgentReadinessState) {
	fake.getAgentReadinessMutex.Lock()
	defer fake.getAgentReadinessMutex.Unlock()
	fake.GetAgentReadinessStub = nil
	fake.getAgentReadinessReturns = struct {
		result1 *domain.AgentReadinessState
	}{result1}
}

func (fake *FakeStateManager) GetAgentReadinessReturnsOnCall(i int, result1 *domain.AgentReadinessState) {
	fake.getAgentReadinessMutex.Lock()
	defer fake.getAgentReadinessMutex.Unlock()
	fake.GetAgentReadinessStub = nil
	if fake.getAgentReadinessReturnsOnCall == nil {
		fake.getAgentReadinessReturnsOnCall = make(map[int]struct {
			result1 *domain.AgentReadinessState
		})
	}
	fake.getAgentReadinessReturnsOnCall[i] = struct {
		result1 *domain.AgentReadinessState
	}{result1}
}

func (fake *FakeStateManager) GetApprovalUIState() *domain.ApprovalUIState {
	fake.getApprovalUIStateMutex.Lock()
	ret, specificReturn := fake.getApprovalUIStateReturnsOnCall[len(fake.getApprovalUIStateArgsForCall)]
	fake.getApprovalUIStateArgsForCall = append(fake.getApprovalUIStateArgsForCall, struct {
	}{})
	stub := fake.GetApprovalUIStateStub
	fakeReturns := fake.getApprovalUIStateReturns
	fake.recordInvocation("GetApprovalUIState", []interface{}{})
	fake.getApprovalUIStateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetApprovalUIStateCallCount() int {
	fake.getApprovalUIStateMutex.RLock()
	defer fake.getApprovalUIStateMutex.RUnlock()
	return len(fake.getApprovalUIStateArgsForCall)
}

func (fake *FakeStateManager) GetApprovalUIStateCalls(stub func() *domain.ApprovalUIState) {
	fake.getApprovalUIStateMutex.Lock()
	defer fake.getApprovalUIStateMutex.Unlock()
	fake.GetApprovalUIStateStub = stub
}

func (fake *FakeStateManager) GetApprovalUIStateReturns(result1 *domain.ApprovalUIState) {
	fake.getApprovalUIStateMutex.Lock()
	defer fake.getApprovalUIStateMutex.Unlock()
	fake.GetApprovalUIStateStub = nil
	fake.getApprovalUIStateReturns = struct {
		result1 *domain.ApprovalUIState
	}{result1}
}

func (fake *FakeStateManager) GetApprovalUIStateReturnsOnCall(i int, result1 *domain.ApprovalUIState) {
	fake.getApprovalUIStateMutex.Lock()
	defer fake.getApprovalUIStateMutex.Unlock()
	fake.GetApprovalUIStateStub = nil
	if fake.getApprovalUIStateReturnsOnCall == nil {
		fake.getApprovalUIStateReturnsOnCall = make(map[int]struct {
			result1 *domain.ApprovalUIState
		})
	}
	fake.getApprovalUIStateReturnsOnCall[i] = struct {
		result1 *domain.ApprovalUIState
	}{result1}
}

func (fake *FakeStateManager) GetChatSession() *domain.ChatSession {
	fake.getChatSessionMutex.Lock()
	ret, specificReturn := fake.getChatSessionReturnsOnCall[len(fake.getChatSessionArgsForCall)]
	fake.getChatSessionArgsForCall = append(fake.getChatSessionArgsForCall, struct {
	}{})
	stub := fake.GetChatSessionStub
	fakeReturns := fake.getChatSessionReturns
	fake.recordInvocation("GetChatSession", []interface{}{})
	fake.getChatSessionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetChatSessionCallCount() int {
	fake.getChatSessionMutex.RLock()
	defer fake.getChatSessionMutex.RUnlock()
	return len(fake.getChatSessionArgsForCall)
}

func (fake *FakeStateManager) GetChatSessionCalls(stub func() *domain.ChatSession) {
	fake.getChatSessionMutex.Lock()
	defer fake.getChatSessionMutex.Unlock()
	fake.GetChatSessionStub = stub
}

func (fake *FakeStateManager) GetChatSessionReturns(result1 *domain.ChatSession) {
	fake.getChatSessionMutex.Lock()
	defer fake.getChatSessionMutex.Unlock()
	fake.GetChatSessionStub = nil
	fake.getChatSessionReturns = struct {
		result1 *domain.ChatSession
	}{result1}
}

func (fake *FakeStateManager) GetChatSessionReturnsOnCall(i int, result1 *domain.ChatSession) {
	fake.getChatSessionMutex.Lock()
	defer fake.getChatSessionMutex.Unlock()
	fake.GetChatSessionStub = nil
	if fake.getChatSessionReturnsOnCall == nil {
		fake.getChatSessionReturnsOnCall = make(map[int]struct {
			result1 *domain.ChatSession
		})
	}
	fake.getChatSessionReturnsOnCall[i] = struct {
		result1 *domain.ChatSession
	}{result1}
}

func (fake *FakeStateManager) GetCurrentView() domain.ViewState {
	fake.getCurrentViewMutex.Lock()
	ret, specificReturn := fake.getCurrentViewReturnsOnCall[len(fake.getCurrentViewArgsForCall)]
	fake.getCurrentViewArgsForCall = append(fake.getCurrentViewArgsForCall, struct {
	}{})
	stub := fake.GetCurrentViewStub
	fakeReturns := fake.getCurrentViewReturns
	fake.recordInvocation("GetCurrentView", []interface{}{})
	fake.getCurrentViewMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetCurrentViewCallCount() int {
	fake.getCurrentViewMutex.RLock()
	defer fake.getCurrentViewMutex.RUnlock()
	return len(fake.getCurrentViewArgsForCall)
}

func (fake *FakeStateManager) GetCurrentViewCalls(stub func() domain.ViewState) {
	fake.getCurrentViewMutex.Lock()
	defer fake.getCurrentViewMutex.Unlock()
	fake.GetCurrentViewStub = stub
}

func (fake *FakeStateManager) GetCurrentViewReturns(result1 domain.ViewState) {
	fake.getCurrentViewMutex.Lock()
	defer fake.getCurrentViewMutex.Unlock()
	fake.GetCurrentViewStub = nil
	fake.getCurrentViewReturns = struct {
		result1 domain.ViewState
	}{result1}
}

func (fake *FakeStateManager) GetCurrentViewReturnsOnCall(i int, result1 domain.ViewState) {
	fake.getCurrentViewMutex.Lock()
	defer fake.getCurrentViewMutex.Unlock()
	fake.GetCurrentViewStub = nil
	if fake.getCurrentViewReturnsOnCall == nil {
		fake.getCurrentViewReturnsOnCall = make(map[int]struct {
			result1 domain.ViewState
		})
	}
	fake.getCurrentViewReturnsOnCall[i] = struct {
		result1 domain.ViewState
	}{result1}
}

func (fake *FakeStateManager) GetDimensions() (int, int) {
	fake.getDimensionsMutex.Lock()
	ret, specificReturn := fake.getDimensionsReturnsOnCall[len(fake.getDimensionsArgsForCall)]
	fake.getDimensionsArgsForCall = append(fake.getDimensionsArgsForCall, struct {
	}{})
	stub := fake.GetDimensionsStub
	fakeReturns := fake.getDimensionsReturns
	fake.recordInvocation("GetDimensions", []interface{}{})
	fake.getDimensionsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStateManager) GetDimensionsCallCount() int {
	fake.getDimensionsMutex.RLock()
	defer fake.getDimensionsMutex.RUnlock()
	return len(fake.getDimensionsArgsForCall)
}

func (fake *FakeStateManager) GetDimensionsCalls(stub func() (int, int)) {
	fake.getDimensionsMutex.Lock()
	defer fake.getDimensionsMutex.Unlock()
	fake.GetDimensionsStub = stub
}

func (fake *FakeStateManager) GetDimensionsReturns(result1 int, result2 int) {
	fake.getDimensionsMutex.Lock()
	defer fake.getDimensionsMutex.Unlock()
	fake.GetDimensionsStub = nil
	fake.getDimensionsReturns = struct {
		result1 int
		result2 int
	}{result1, result2}
}

func (fake *FakeStateManager) GetDimensionsReturnsOnCall(i int, result1 int, result2 int) {
	fake.getDimensionsMutex.Lock()
	defer fake.getDimensionsMutex.Unlock()
	fake.GetDimensionsStub = nil
	if fake.getDimensionsReturnsOnCall == nil {
		fake.getDimensionsReturnsOnCall = make(map[int]struct {
			result1 int
			result2 int
		})
	}
	fake.getDimensionsReturnsOnCall[i] = struct {
		result1 int
		result2 int
	}{result1, result2}
}

func (fake *FakeStateManager) GetFileSelectionState() *domain.FileSelectionState {
	fake.getFileSelectionStateMutex.Lock()
	ret, specificReturn := fake.getFileSelectionStateReturnsOnCall[len(fake.getFileSelectionStateArgsForCall)]
	fake.getFileSelectionStateArgsForCall = append(fake.getFileSelectionStateArgsForCall, struct {
	}{})
	stub := fake.GetFileSelectionStateStub
	fakeReturns := fake.getFileSelectionStateReturns
	fake.recordInvocation("GetFileSelectionState", []interface{}{})
	fake.getFileSelectionStateMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetFileSelectionStateCallCount() int {
	fake.getFileSelectionStateMutex.RLock()
	defer fake.getFileSelectionStateMutex.RUnlock()
	return len(fake.getFileSelectionStateArgsForCall)
}

func (fake *FakeStateManager) GetFileSelectionStateCalls(stub func() *domain.FileSelectionState) {
	fake.getFileSelectionStateMutex.Lock()
	defer fake.getFileSelectionStateMutex.Unlock()
	fake.GetFileSelectionStateStub = stub
}

func (fake *FakeStateManager) GetFileSelectionStateReturns(result1 *domain.FileSelectionState) {
	fake.getFileSelectionStateMutex.Lock()
	defer fake.getFileSelectionStateMutex.Unlock()
	fake.GetFileSelectionStateStub = nil
	fake.getFileSelectionStateReturns = struct {
		result1 *domain.FileSelectionState
	}{result1}
}

func (fake *FakeStateManager) GetFileSelectionStateReturnsOnCall(i int, result1 *domain.FileSelectionState) {
	fake.getFileSelectionStateMutex.Lock()
	defer fake.getFileSelectionStateMutex.Unlock()
	fake.GetFileSelectionStateStub = nil
	if fake.getFileSelectionStateReturnsOnCall == nil {
		fake.getFileSelectionStateReturnsOnCall = make(map[int]struct {
			result1 *domain.FileSelectionState
		})
	}
	fake.getFileSelectionStateReturnsOnCall[i] = struct {
		result1 *domain.FileSelectionState
	}{result1}
}

func (fake *FakeStateManager) GetTodos() []domain.TodoItem {
	fake.getTodosMutex.Lock()
	ret, specificReturn := fake.getTodosReturnsOnCall[len(fake.getTodosArgsForCall)]
	fake.getTodosArgsForCall = append(fake.getTodosArgsForCall, struct {
	}{})
	stub := fake.GetTodosStub
	fakeReturns := fake.getTodosReturns
	fake.recordInvocation("GetTodos", []interface{}{})
	fake.getTodosMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetTodosCallCount() int {
	fake.getTodosMutex.RLock()
	defer fake.getTodosMutex.RUnlock()
	return len(fake.getTodosArgsForCall)
}

func (fake *FakeStateManager) GetTodosCalls(stub func() []domain.TodoItem) {
	fake.getTodosMutex.Lock()
	defer fake.getTodosMutex.Unlock()
	fake.GetTodosStub = stub
}

func (fake *FakeStateManager) GetTodosReturns(result1 []domain.TodoItem) {
	fake.getTodosMutex.Lock()
	defer fake.getTodosMutex.Unlock()
	fake.GetTodosStub = nil
	fake.getTodosReturns = struct {
		result1 []domain.TodoItem
	}{result1}
}

func (fake *FakeStateManager) GetTodosReturnsOnCall(i int, result1 []domain.TodoItem) {
	fake.getTodosMutex.Lock()
	defer fake.getTodosMutex.Unlock()
	fake.GetTodosStub = nil
	if fake.getTodosReturnsOnCall == nil {
		fake.getTodosReturnsOnCall = make(map[int]struct {
			result1 []domain.TodoItem
		})
	}
	fake.getTodosReturnsOnCall[i] = struct {
		result1 []domain.TodoItem
	}{result1}
}

func (fake *FakeStateManager) GetToolExecution() *domain.ToolExecutionSession {
	fake.getToolExecutionMutex.Lock()
	ret, specificReturn := fake.getToolExecutionReturnsOnCall[len(fake.getToolExecutionArgsForCall)]
	fake.getToolExecutionArgsForCall = append(fake.getToolExecutionArgsForCall, struct {
	}{})
	stub := fake.GetToolExecutionStub
	fakeReturns := fake.getToolExecutionReturns
	fake.recordInvocation("GetToolExecution", []interface{}{})
	fake.getToolExecutionMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) GetToolExecutionCallCount() int {
	fake.getToolExecutionMutex.RLock()
	defer fake.getToolExecutionMutex.RUnlock()
	return len(fake.getToolExecutionArgsForCall)
}

func (fake *FakeStateManager) GetToolExecutionCalls(stub func() *domain.ToolExecutionSession) {
	fake.getToolExecutionMutex.Lock()
	defer fake.getToolExecutionMutex.Unlock()
	fake.GetToolExecutionStub = stub
}

func (fake *FakeStateManager) GetToolExecutionReturns(result1 *domain.ToolExecutionSession) {
	fake.getToolExecutionMutex.Lock()
	defer fake.getToolExecutionMutex.Unlock()
	fake.GetToolExecutionStub = nil
	fake.getToolExecutionReturns = struct {
		result1 *domain.ToolExecutionSession
	}{result1}
}

func (fake *FakeStateManager) GetToolExecutionReturnsOnCall(i int, result1 *domain.ToolExecutionSession) {
	fake.getToolExecutionMutex.Lock()
	defer fake.getToolExecutionMutex.Unlock()
	fake.GetToolExecutionStub = nil
	if fake.getToolExecutionReturnsOnCall == nil {
		fake.getToolExecutionReturnsOnCall = make(map[int]struct {
			result1 *domain.ToolExecutionSession
		})
	}
	fake.getToolExecutionReturnsOnCall[i] = struct {
		result1 *domain.ToolExecutionSession
	}{result1}
}

func (fake *FakeStateManager) InitializeAgentReadiness(arg1 int) {
	fake.initializeAgentReadinessMutex.Lock()
	fake.initializeAgentReadinessArgsForCall = append(fake.initializeAgentReadinessArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.InitializeAgentReadinessStub
	fake.recordInvocation("InitializeAgentReadiness", []interface{}{arg1})
	fake.initializeAgentReadinessMutex.Unlock()
	if stub != nil {
		fake.InitializeAgentReadinessStub(arg1)
	}
}

func (fake *FakeStateManager) InitializeAgentReadinessCallCount() int {
	fake.initializeAgentReadinessMutex.RLock()
	defer fake.initializeAgentReadinessMutex.RUnlock()
	return len(fake.initializeAgentReadinessArgsForCall)
}

func (fake *FakeStateManager) InitializeAgentReadinessCalls(stub func(int)) {
	fake.initializeAgentReadinessMutex.Lock()
	defer fake.initializeAgentReadinessMutex.Unlock()
	fake.InitializeAgentReadinessStub = stub
}

func (fake *FakeStateManager) InitializeAgentReadinessArgsForCall(i int) int {
	fake.initializeAgentReadinessMutex.RLock()
	defer fake.initializeAgentReadinessMutex.RUnlock()
	argsForCall := fake.initializeAgentReadinessArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) IsAgentBusy() bool {
	fake.isAgentBusyMutex.Lock()
	ret, specificReturn := fake.isAgentBusyReturnsOnCall[len(fake.isAgentBusyArgsForCall)]
	fake.isAgentBusyArgsForCall = append(fake.isAgentBusyArgsForCall, struct {
	}{})
	stub := fake.IsAgentBusyStub
	fakeReturns := fake.isAgentBusyReturns
	fake.recordInvocation("IsAgentBusy", []interface{}{})
	fake.isAgentBusyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) IsAgentBusyCallCount() int {
	fake.isAgentBusyMutex.RLock()
	defer fake.isAgentBusyMutex.RUnlock()
	return len(fake.isAgentBusyArgsForCall)
}

func (fake *FakeStateManager) IsAgentBusyCalls(stub func() bool) {
	fake.isAgentBusyMutex.Lock()
	defer fake.isAgentBusyMutex.Unlock()
	fake.IsAgentBusyStub = stub
}

func (fake *FakeStateManager) IsAgentBusyReturns(result1 bool) {
	fake.isAgentBusyMutex.Lock()
	defer fake.isAgentBusyMutex.Unlock()
	fake.IsAgentBusyStub = nil
	fake.isAgentBusyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStateManager) IsAgentBusyReturnsOnCall(i int, result1 bool) {
	fake.isAgentBusyMutex.Lock()
	defer fake.isAgentBusyMutex.Unlock()
	fake.IsAgentBusyStub = nil
	if fake.isAgentBusyReturnsOnCall == nil {
		fake.isAgentBusyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isAgentBusyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeStateManager) SetAgentError(arg1 string, arg2 error) {
	fake.setAgentErrorMutex.Lock()
	fake.setAgentErrorArgsForCall = append(fake.setAgentErrorArgsForCall, struct {
		arg1 string
		arg2 error
	}{arg1, arg2})
	stub := fake.SetAgentErrorStub
	fake.recordInvocation("SetAgentError", []interface{}{arg1, arg2})
	fake.setAgentErrorMutex.Unlock()
	if stub != nil {
		fake.SetAgentErrorStub(arg1, arg2)
	}
}

func (fake *FakeStateManager) SetAgentErrorCallCount() int {
	fake.setAgentErrorMutex.RLock()
	defer fake.setAgentErrorMutex.RUnlock()
	return len(fake.setAgentErrorArgsForCall)
}

func (fake *FakeStateManager) SetAgentErrorCalls(stub func(string, error)) {
	fake.setAgentErrorMutex.Lock()
	defer fake.setAgentErrorMutex.Unlock()
	fake.SetAgentErrorStub = stub
}

func (fake *FakeStateManager) SetAgentErrorArgsForCall(i int) (string, error) {
	fake.setAgentErrorMutex.RLock()
	defer fake.setAgentErrorMutex.RUnlock()
	argsForCall := fake.setAgentErrorArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStateManager) SetAgentMode(arg1 domain.AgentMode) {
	fake.setAgentModeMutex.Lock()
	fake.setAgentModeArgsForCall = append(fake.setAgentModeArgsForCall, struct {
		arg1 domain.AgentMode
	}{arg1})
	stub := fake.SetAgentModeStub
	fake.recordInvocation("SetAgentMode", []interface{}{arg1})
	fake.setAgentModeMutex.Unlock()
	if stub != nil {
		fake.SetAgentModeStub(arg1)
	}
}

func (fake *FakeStateManager) SetAgentModeCallCount() int {
	fake.setAgentModeMutex.RLock()
	defer fake.setAgentModeMutex.RUnlock()
	return len(fake.setAgentModeArgsForCall)
}

func (fake *FakeStateManager) SetAgentModeCalls(stub func(domain.AgentMode)) {
	fake.setAgentModeMutex.Lock()
	defer fake.setAgentModeMutex.Unlock()
	fake.SetAgentModeStub = stub
}

func (fake *FakeStateManager) SetAgentModeArgsForCall(i int) domain.AgentMode {
	fake.setAgentModeMutex.RLock()
	defer fake.setAgentModeMutex.RUnlock()
	argsForCall := fake.setAgentModeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) SetApprovalSelectedIndex(arg1 int) {
	fake.setApprovalSelectedIndexMutex.Lock()
	fake.setApprovalSelectedIndexArgsForCall = append(fake.setApprovalSelectedIndexArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.SetApprovalSelectedIndexStub
	fake.recordInvocation("SetApprovalSelectedIndex", []interface{}{arg1})
	fake.setApprovalSelectedIndexMutex.Unlock()
	if stub != nil {
		fake.SetApprovalSelectedIndexStub(arg1)
	}
}

func (fake *FakeStateManager) SetApprovalSelectedIndexCallCount() int {
	fake.setApprovalSelectedIndexMutex.RLock()
	defer fake.setApprovalSelectedIndexMutex.RUnlock()
	return len(fake.setApprovalSelectedIndexArgsForCall)
}

func (fake *FakeStateManager) SetApprovalSelectedIndexCalls(stub func(int)) {
	fake.setApprovalSelectedIndexMutex.Lock()
	defer fake.setApprovalSelectedIndexMutex.Unlock()
	fake.SetApprovalSelectedIndexStub = stub
}

func (fake *FakeStateManager) SetApprovalSelectedIndexArgsForCall(i int) int {
	fake.setApprovalSelectedIndexMutex.RLock()
	defer fake.setApprovalSelectedIndexMutex.RUnlock()
	argsForCall := fake.setApprovalSelectedIndexArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) SetChatPending() {
	fake.setChatPendingMutex.Lock()
	fake.setChatPendingArgsForCall = append(fake.setChatPendingArgsForCall, struct {
	}{})
	stub := fake.SetChatPendingStub
	fake.recordInvocation("SetChatPending", []interface{}{})
	fake.setChatPendingMutex.Unlock()
	if stub != nil {
		fake.SetChatPendingStub()
	}
}

func (fake *FakeStateManager) SetChatPendingCallCount() int {
	fake.setChatPendingMutex.RLock()
	defer fake.setChatPendingMutex.RUnlock()
	return len(fake.setChatPendingArgsForCall)
}

func (fake *FakeStateManager) SetChatPendingCalls(stub func()) {
	fake.setChatPendingMutex.Lock()
	defer fake.setChatPendingMutex.Unlock()
	fake.SetChatPendingStub = stub
}

func (fake *FakeStateManager) SetDimensions(arg1 int, arg2 int) {
	fake.setDimensionsMutex.Lock()
	fake.setDimensionsArgsForCall = append(fake.setDimensionsArgsForCall, struct {
		arg1 int
		arg2 int
	}{arg1, arg2})
	stub := fake.SetDimensionsStub
	fake.recordInvocation("SetDimensions", []interface{}{arg1, arg2})
	fake.setDimensionsMutex.Unlock()
	if stub != nil {
		fake.SetDimensionsStub(arg1, arg2)
	}
}

func (fake *FakeStateManager) SetDimensionsCallCount() int {
	fake.setDimensionsMutex.RLock()
	defer fake.setDimensionsMutex.RUnlock()
	return len(fake.setDimensionsArgsForCall)
}

func (fake *FakeStateManager) SetDimensionsCalls(stub func(int, int)) {
	fake.setDimensionsMutex.Lock()
	defer fake.setDimensionsMutex.Unlock()
	fake.SetDimensionsStub = stub
}

func (fake *FakeStateManager) SetDimensionsArgsForCall(i int) (int, int) {
	fake.setDimensionsMutex.RLock()
	defer fake.setDimensionsMutex.RUnlock()
	argsForCall := fake.setDimensionsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStateManager) SetFileSelectedIndex(arg1 int) {
	fake.setFileSelectedIndexMutex.Lock()
	fake.setFileSelectedIndexArgsForCall = append(fake.setFileSelectedIndexArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.SetFileSelectedIndexStub
	fake.recordInvocation("SetFileSelectedIndex", []interface{}{arg1})
	fake.setFileSelectedIndexMutex.Unlock()
	if stub != nil {
		fake.SetFileSelectedIndexStub(arg1)
	}
}

func (fake *FakeStateManager) SetFileSelectedIndexCallCount() int {
	fake.setFileSelectedIndexMutex.RLock()
	defer fake.setFileSelectedIndexMutex.RUnlock()
	return len(fake.setFileSelectedIndexArgsForCall)
}

func (fake *FakeStateManager) SetFileSelectedIndexCalls(stub func(int)) {
	fake.setFileSelectedIndexMutex.Lock()
	defer fake.setFileSelectedIndexMutex.Unlock()
	fake.SetFileSelectedIndexStub = stub
}

func (fake *FakeStateManager) SetFileSelectedIndexArgsForCall(i int) int {
	fake.setFileSelectedIndexMutex.RLock()
	defer fake.setFileSelectedIndexMutex.RUnlock()
	argsForCall := fake.setFileSelectedIndexArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) SetTodos(arg1 []domain.TodoItem) {
	var arg1Copy []domain.TodoItem
	if arg1 != nil {
		arg1Copy = make([]domain.TodoItem, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setTodosMutex.Lock()
	fake.setTodosArgsForCall = append(fake.setTodosArgsForCall, struct {
		arg1 []domain.TodoItem
	}{arg1Copy})
	stub := fake.SetTodosStub
	fake.recordInvocation("SetTodos", []interface{}{arg1Copy})
	fake.setTodosMutex.Unlock()
	if stub != nil {
		fake.SetTodosStub(arg1)
	}
}

func (fake *FakeStateManager) SetTodosCallCount() int {
	fake.setTodosMutex.RLock()
	defer fake.setTodosMutex.RUnlock()
	return len(fake.setTodosArgsForCall)
}

func (fake *FakeStateManager) SetTodosCalls(stub func([]domain.TodoItem)) {
	fake.setTodosMutex.Lock()
	defer fake.setTodosMutex.Unlock()
	fake.SetTodosStub = stub
}

func (fake *FakeStateManager) SetTodosArgsForCall(i int) []domain.TodoItem {
	fake.setTodosMutex.RLock()
	defer fake.setTodosMutex.RUnlock()
	argsForCall := fake.setTodosArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) SetupApprovalUIState(arg1 *sdk.ChatCompletionMessageToolCall, arg2 chan domain.ApprovalAction) {
	fake.setupApprovalUIStateMutex.Lock()
	fake.setupApprovalUIStateArgsForCall = append(fake.setupApprovalUIStateArgsForCall, struct {
		arg1 *sdk.ChatCompletionMessageToolCall
		arg2 chan domain.ApprovalAction
	}{arg1, arg2})
	stub := fake.SetupApprovalUIStateStub
	fake.recordInvocation("SetupApprovalUIState", []interface{}{arg1, arg2})
	fake.setupApprovalUIStateMutex.Unlock()
	if stub != nil {
		fake.SetupApprovalUIStateStub(arg1, arg2)
	}
}

func (fake *FakeStateManager) SetupApprovalUIStateCallCount() int {
	fake.setupApprovalUIStateMutex.RLock()
	defer fake.setupApprovalUIStateMutex.RUnlock()
	return len(fake.setupApprovalUIStateArgsForCall)
}

func (fake *FakeStateManager) SetupApprovalUIStateCalls(stub func(*sdk.ChatCompletionMessageToolCall, chan domain.ApprovalAction)) {
	fake.setupApprovalUIStateMutex.Lock()
	defer fake.setupApprovalUIStateMutex.Unlock()
	fake.SetupApprovalUIStateStub = stub
}

func (fake *FakeStateManager) SetupApprovalUIStateArgsForCall(i int) (*sdk.ChatCompletionMessageToolCall, chan domain.ApprovalAction) {
	fake.setupApprovalUIStateMutex.RLock()
	defer fake.setupApprovalUIStateMutex.RUnlock()
	argsForCall := fake.setupApprovalUIStateArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStateManager) SetupFileSelection(arg1 []string) {
	var arg1Copy []string
	if arg1 != nil {
		arg1Copy = make([]string, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setupFileSelectionMutex.Lock()
	fake.setupFileSelectionArgsForCall = append(fake.setupFileSelectionArgsForCall, struct {
		arg1 []string
	}{arg1Copy})
	stub := fake.SetupFileSelectionStub
	fake.recordInvocation("SetupFileSelection", []interface{}{arg1Copy})
	fake.setupFileSelectionMutex.Unlock()
	if stub != nil {
		fake.SetupFileSelectionStub(arg1)
	}
}

func (fake *FakeStateManager) SetupFileSelectionCallCount() int {
	fake.setupFileSelectionMutex.RLock()
	defer fake.setupFileSelectionMutex.RUnlock()
	return len(fake.setupFileSelectionArgsForCall)
}

func (fake *FakeStateManager) SetupFileSelectionCalls(stub func([]string)) {
	fake.setupFileSelectionMutex.Lock()
	defer fake.setupFileSelectionMutex.Unlock()
	fake.SetupFileSelectionStub = stub
}

func (fake *FakeStateManager) SetupFileSelectionArgsForCall(i int) []string {
	fake.setupFileSelectionMutex.RLock()
	defer fake.setupFileSelectionMutex.RUnlock()
	argsForCall := fake.setupFileSelectionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) StartChatSession(arg1 string, arg2 string, arg3 <-chan domain.ChatEvent) error {
	fake.startChatSessionMutex.Lock()
	ret, specificReturn := fake.startChatSessionReturnsOnCall[len(fake.startChatSessionArgsForCall)]
	fake.startChatSessionArgsForCall = append(fake.startChatSessionArgsForCall, struct {
		arg1 string
		arg2 string
		arg3 <-chan domain.ChatEvent
	}{arg1, arg2, arg3})
	stub := fake.StartChatSessionStub
	fakeReturns := fake.startChatSessionReturns
	fake.recordInvocation("StartChatSession", []interface{}{arg1, arg2, arg3})
	fake.startChatSessionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) StartChatSessionCallCount() int {
	fake.startChatSessionMutex.RLock()
	defer fake.startChatSessionMutex.RUnlock()
	return len(fake.startChatSessionArgsForCall)
}

func (fake *FakeStateManager) StartChatSessionCalls(stub func(string, string, <-chan domain.ChatEvent) error) {
	fake.startChatSessionMutex.Lock()
	defer fake.startChatSessionMutex.Unlock()
	fake.StartChatSessionStub = stub
}

func (fake *FakeStateManager) StartChatSessionArgsForCall(i int) (string, string, <-chan domain.ChatEvent) {
	fake.startChatSessionMutex.RLock()
	defer fake.startChatSessionMutex.RUnlock()
	argsForCall := fake.startChatSessionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStateManager) StartChatSessionReturns(result1 error) {
	fake.startChatSessionMutex.Lock()
	defer fake.startChatSessionMutex.Unlock()
	fake.StartChatSessionStub = nil
	fake.startChatSessionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) StartChatSessionReturnsOnCall(i int, result1 error) {
	fake.startChatSessionMutex.Lock()
	defer fake.startChatSessionMutex.Unlock()
	fake.StartChatSessionStub = nil
	if fake.startChatSessionReturnsOnCall == nil {
		fake.startChatSessionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startChatSessionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) StartToolExecution(arg1 []sdk.ChatCompletionMessageToolCall) error {
	var arg1Copy []sdk.ChatCompletionMessageToolCall
	if arg1 != nil {
		arg1Copy = make([]sdk.ChatCompletionMessageToolCall, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.startToolExecutionMutex.Lock()
	ret, specificReturn := fake.startToolExecutionReturnsOnCall[len(fake.startToolExecutionArgsForCall)]
	fake.startToolExecutionArgsForCall = append(fake.startToolExecutionArgsForCall, struct {
		arg1 []sdk.ChatCompletionMessageToolCall
	}{arg1Copy})
	stub := fake.StartToolExecutionStub
	fakeReturns := fake.startToolExecutionReturns
	fake.recordInvocation("StartToolExecution", []interface{}{arg1Copy})
	fake.startToolExecutionMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) StartToolExecutionCallCount() int {
	fake.startToolExecutionMutex.RLock()
	defer fake.startToolExecutionMutex.RUnlock()
	return len(fake.startToolExecutionArgsForCall)
}

func (fake *FakeStateManager) StartToolExecutionCalls(stub func([]sdk.ChatCompletionMessageToolCall) error) {
	fake.startToolExecutionMutex.Lock()
	defer fake.startToolExecutionMutex.Unlock()
	fake.StartToolExecutionStub = stub
}

func (fake *FakeStateManager) StartToolExecutionArgsForCall(i int) []sdk.ChatCompletionMessageToolCall {
	fake.startToolExecutionMutex.RLock()
	defer fake.startToolExecutionMutex.RUnlock()
	argsForCall := fake.startToolExecutionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) StartToolExecutionReturns(result1 error) {
	fake.startToolExecutionMutex.Lock()
	defer fake.startToolExecutionMutex.Unlock()
	fake.StartToolExecutionStub = nil
	fake.startToolExecutionReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) StartToolExecutionReturnsOnCall(i int, result1 error) {
	fake.startToolExecutionMutex.Lock()
	defer fake.startToolExecutionMutex.Unlock()
	fake.StartToolExecutionStub = nil
	if fake.startToolExecutionReturnsOnCall == nil {
		fake.startToolExecutionReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startToolExecutionReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) TransitionToView(arg1 domain.ViewState) error {
	fake.transitionToViewMutex.Lock()
	ret, specificReturn := fake.transitionToViewReturnsOnCall[len(fake.transitionToViewArgsForCall)]
	fake.transitionToViewArgsForCall = append(fake.transitionToViewArgsForCall, struct {
		arg1 domain.ViewState
	}{arg1})
	stub := fake.TransitionToViewStub
	fakeReturns := fake.transitionToViewReturns
	fake.recordInvocation("TransitionToView", []interface{}{arg1})
	fake.transitionToViewMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) TransitionToViewCallCount() int {
	fake.transitionToViewMutex.RLock()
	defer fake.transitionToViewMutex.RUnlock()
	return len(fake.transitionToViewArgsForCall)
}

func (fake *FakeStateManager) TransitionToViewCalls(stub func(domain.ViewState) error) {
	fake.transitionToViewMutex.Lock()
	defer fake.transitionToViewMutex.Unlock()
	fake.TransitionToViewStub = stub
}

func (fake *FakeStateManager) TransitionToViewArgsForCall(i int) domain.ViewState {
	fake.transitionToViewMutex.RLock()
	defer fake.transitionToViewMutex.RUnlock()
	argsForCall := fake.transitionToViewArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) TransitionToViewReturns(result1 error) {
	fake.transitionToViewMutex.Lock()
	defer fake.transitionToViewMutex.Unlock()
	fake.TransitionToViewStub = nil
	fake.transitionToViewReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) TransitionToViewReturnsOnCall(i int, result1 error) {
	fake.transitionToViewMutex.Lock()
	defer fake.transitionToViewMutex.Unlock()
	fake.TransitionToViewStub = nil
	if fake.transitionToViewReturnsOnCall == nil {
		fake.transitionToViewReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.transitionToViewReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) UpdateAgentStatus(arg1 string, arg2 domain.AgentState, arg3 string, arg4 string, arg5 string) {
	fake.updateAgentStatusMutex.Lock()
	fake.updateAgentStatusArgsForCall = append(fake.updateAgentStatusArgsForCall, struct {
		arg1 string
		arg2 domain.AgentState
		arg3 string
		arg4 string
		arg5 string
	}{arg1, arg2, arg3, arg4, arg5})
	stub := fake.UpdateAgentStatusStub
	fake.recordInvocation("UpdateAgentStatus", []interface{}{arg1, arg2, arg3, arg4, arg5})
	fake.updateAgentStatusMutex.Unlock()
	if stub != nil {
		fake.UpdateAgentStatusStub(arg1, arg2, arg3, arg4, arg5)
	}
}

func (fake *FakeStateManager) UpdateAgentStatusCallCount() int {
	fake.updateAgentStatusMutex.RLock()
	defer fake.updateAgentStatusMutex.RUnlock()
	return len(fake.updateAgentStatusArgsForCall)
}

func (fake *FakeStateManager) UpdateAgentStatusCalls(stub func(string, domain.AgentState, string, string, string)) {
	fake.updateAgentStatusMutex.Lock()
	defer fake.updateAgentStatusMutex.Unlock()
	fake.UpdateAgentStatusStub = stub
}

func (fake *FakeStateManager) UpdateAgentStatusArgsForCall(i int) (string, domain.AgentState, string, string, string) {
	fake.updateAgentStatusMutex.RLock()
	defer fake.updateAgentStatusMutex.RUnlock()
	argsForCall := fake.updateAgentStatusArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5
}

func (fake *FakeStateManager) UpdateChatStatus(arg1 domain.ChatStatus) error {
	fake.updateChatStatusMutex.Lock()
	ret, specificReturn := fake.updateChatStatusReturnsOnCall[len(fake.updateChatStatusArgsForCall)]
	fake.updateChatStatusArgsForCall = append(fake.updateChatStatusArgsForCall, struct {
		arg1 domain.ChatStatus
	}{arg1})
	stub := fake.UpdateChatStatusStub
	fakeReturns := fake.updateChatStatusReturns
	fake.recordInvocation("UpdateChatStatus", []interface{}{arg1})
	fake.updateChatStatusMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeStateManager) UpdateChatStatusCallCount() int {
	fake.updateChatStatusMutex.RLock()
	defer fake.updateChatStatusMutex.RUnlock()
	return len(fake.updateChatStatusArgsForCall)
}

func (fake *FakeStateManager) UpdateChatStatusCalls(stub func(domain.ChatStatus) error) {
	fake.updateChatStatusMutex.Lock()
	defer fake.updateChatStatusMutex.Unlock()
	fake.UpdateChatStatusStub = stub
}

func (fake *FakeStateManager) UpdateChatStatusArgsForCall(i int) domain.ChatStatus {
	fake.updateChatStatusMutex.RLock()
	defer fake.updateChatStatusMutex.RUnlock()
	argsForCall := fake.updateChatStatusArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) UpdateChatStatusReturns(result1 error) {
	fake.updateChatStatusMutex.Lock()
	defer fake.updateChatStatusMutex.Unlock()
	fake.UpdateChatStatusStub = nil
	fake.updateChatStatusReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) UpdateChatStatusReturnsOnCall(i int, result1 error) {
	fake.updateChatStatusMutex.Lock()
	defer fake.updateChatStatusMutex.Unlock()
	fake.UpdateChatStatusStub = nil
	if fake.updateChatStatusReturnsOnCall == nil {
		fake.updateChatStatusReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateChatStatusReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeStateManager) UpdateFileSearchQuery(arg1 string) {
	fake.updateFileSearchQueryMutex.Lock()
	fake.updateFileSearchQueryArgsForCall = append(fake.updateFileSearchQueryArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.UpdateFileSearchQueryStub
	fake.recordInvocation("UpdateFileSearchQuery", []interface{}{arg1})
	fake.updateFileSearchQueryMutex.Unlock()
	if stub != nil {
		fake.UpdateFileSearchQueryStub(arg1)
	}
}

func (fake *FakeStateManager) UpdateFileSearchQueryCallCount() int {
	fake.updateFileSearchQueryMutex.RLock()
	defer fake.updateFileSearchQueryMutex.RUnlock()
	return len(fake.updateFileSearchQueryArgsForCall)
}

func (fake *FakeStateManager) UpdateFileSearchQueryCalls(stub func(string)) {
	fake.updateFileSearchQueryMutex.Lock()
	defer fake.updateFileSearchQueryMutex.Unlock()
	fake.UpdateFileSearchQueryStub = stub
}

func (fake *FakeStateManager) UpdateFileSearchQueryArgsForCall(i int) string {
	fake.updateFileSearchQueryMutex.RLock()
	defer fake.updateFileSearchQueryMutex.RUnlock()
	argsForCall := fake.updateFileSearchQueryArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeStateManager) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStateManager) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ domain.StateManager = new(FakeStateManager)
