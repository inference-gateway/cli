// Code generated by counterfeiter. DO NOT EDIT.
package generated

import (
	"sync"

	"github.com/inference-gateway/cli/internal/domain"
	"github.com/inference-gateway/cli/internal/ui"
)

type FakeConversationRenderer struct {
	CanScrollDownStub        func() bool
	canScrollDownMutex       sync.RWMutex
	canScrollDownArgsForCall []struct {
	}
	canScrollDownReturns struct {
		result1 bool
	}
	canScrollDownReturnsOnCall map[int]struct {
		result1 bool
	}
	CanScrollUpStub        func() bool
	canScrollUpMutex       sync.RWMutex
	canScrollUpArgsForCall []struct {
	}
	canScrollUpReturns struct {
		result1 bool
	}
	canScrollUpReturnsOnCall map[int]struct {
		result1 bool
	}
	GetScrollOffsetStub        func() int
	getScrollOffsetMutex       sync.RWMutex
	getScrollOffsetArgsForCall []struct {
	}
	getScrollOffsetReturns struct {
		result1 int
	}
	getScrollOffsetReturnsOnCall map[int]struct {
		result1 int
	}
	IsToolResultExpandedStub        func(int) bool
	isToolResultExpandedMutex       sync.RWMutex
	isToolResultExpandedArgsForCall []struct {
		arg1 int
	}
	isToolResultExpandedReturns struct {
		result1 bool
	}
	isToolResultExpandedReturnsOnCall map[int]struct {
		result1 bool
	}
	RenderStub        func() string
	renderMutex       sync.RWMutex
	renderArgsForCall []struct {
	}
	renderReturns struct {
		result1 string
	}
	renderReturnsOnCall map[int]struct {
		result1 string
	}
	SetConversationStub        func([]domain.ConversationEntry)
	setConversationMutex       sync.RWMutex
	setConversationArgsForCall []struct {
		arg1 []domain.ConversationEntry
	}
	SetHeightStub        func(int)
	setHeightMutex       sync.RWMutex
	setHeightArgsForCall []struct {
		arg1 int
	}
	SetWidthStub        func(int)
	setWidthMutex       sync.RWMutex
	setWidthArgsForCall []struct {
		arg1 int
	}
	ToggleAllToolResultsExpansionStub        func()
	toggleAllToolResultsExpansionMutex       sync.RWMutex
	toggleAllToolResultsExpansionArgsForCall []struct {
	}
	ToggleToolResultExpansionStub        func(int)
	toggleToolResultExpansionMutex       sync.RWMutex
	toggleToolResultExpansionArgsForCall []struct {
		arg1 int
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeConversationRenderer) CanScrollDown() bool {
	fake.canScrollDownMutex.Lock()
	ret, specificReturn := fake.canScrollDownReturnsOnCall[len(fake.canScrollDownArgsForCall)]
	fake.canScrollDownArgsForCall = append(fake.canScrollDownArgsForCall, struct {
	}{})
	stub := fake.CanScrollDownStub
	fakeReturns := fake.canScrollDownReturns
	fake.recordInvocation("CanScrollDown", []interface{}{})
	fake.canScrollDownMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConversationRenderer) CanScrollDownCallCount() int {
	fake.canScrollDownMutex.RLock()
	defer fake.canScrollDownMutex.RUnlock()
	return len(fake.canScrollDownArgsForCall)
}

func (fake *FakeConversationRenderer) CanScrollDownCalls(stub func() bool) {
	fake.canScrollDownMutex.Lock()
	defer fake.canScrollDownMutex.Unlock()
	fake.CanScrollDownStub = stub
}

func (fake *FakeConversationRenderer) CanScrollDownReturns(result1 bool) {
	fake.canScrollDownMutex.Lock()
	defer fake.canScrollDownMutex.Unlock()
	fake.CanScrollDownStub = nil
	fake.canScrollDownReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConversationRenderer) CanScrollDownReturnsOnCall(i int, result1 bool) {
	fake.canScrollDownMutex.Lock()
	defer fake.canScrollDownMutex.Unlock()
	fake.CanScrollDownStub = nil
	if fake.canScrollDownReturnsOnCall == nil {
		fake.canScrollDownReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.canScrollDownReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConversationRenderer) CanScrollUp() bool {
	fake.canScrollUpMutex.Lock()
	ret, specificReturn := fake.canScrollUpReturnsOnCall[len(fake.canScrollUpArgsForCall)]
	fake.canScrollUpArgsForCall = append(fake.canScrollUpArgsForCall, struct {
	}{})
	stub := fake.CanScrollUpStub
	fakeReturns := fake.canScrollUpReturns
	fake.recordInvocation("CanScrollUp", []interface{}{})
	fake.canScrollUpMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConversationRenderer) CanScrollUpCallCount() int {
	fake.canScrollUpMutex.RLock()
	defer fake.canScrollUpMutex.RUnlock()
	return len(fake.canScrollUpArgsForCall)
}

func (fake *FakeConversationRenderer) CanScrollUpCalls(stub func() bool) {
	fake.canScrollUpMutex.Lock()
	defer fake.canScrollUpMutex.Unlock()
	fake.CanScrollUpStub = stub
}

func (fake *FakeConversationRenderer) CanScrollUpReturns(result1 bool) {
	fake.canScrollUpMutex.Lock()
	defer fake.canScrollUpMutex.Unlock()
	fake.CanScrollUpStub = nil
	fake.canScrollUpReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConversationRenderer) CanScrollUpReturnsOnCall(i int, result1 bool) {
	fake.canScrollUpMutex.Lock()
	defer fake.canScrollUpMutex.Unlock()
	fake.CanScrollUpStub = nil
	if fake.canScrollUpReturnsOnCall == nil {
		fake.canScrollUpReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.canScrollUpReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConversationRenderer) GetScrollOffset() int {
	fake.getScrollOffsetMutex.Lock()
	ret, specificReturn := fake.getScrollOffsetReturnsOnCall[len(fake.getScrollOffsetArgsForCall)]
	fake.getScrollOffsetArgsForCall = append(fake.getScrollOffsetArgsForCall, struct {
	}{})
	stub := fake.GetScrollOffsetStub
	fakeReturns := fake.getScrollOffsetReturns
	fake.recordInvocation("GetScrollOffset", []interface{}{})
	fake.getScrollOffsetMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConversationRenderer) GetScrollOffsetCallCount() int {
	fake.getScrollOffsetMutex.RLock()
	defer fake.getScrollOffsetMutex.RUnlock()
	return len(fake.getScrollOffsetArgsForCall)
}

func (fake *FakeConversationRenderer) GetScrollOffsetCalls(stub func() int) {
	fake.getScrollOffsetMutex.Lock()
	defer fake.getScrollOffsetMutex.Unlock()
	fake.GetScrollOffsetStub = stub
}

func (fake *FakeConversationRenderer) GetScrollOffsetReturns(result1 int) {
	fake.getScrollOffsetMutex.Lock()
	defer fake.getScrollOffsetMutex.Unlock()
	fake.GetScrollOffsetStub = nil
	fake.getScrollOffsetReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeConversationRenderer) GetScrollOffsetReturnsOnCall(i int, result1 int) {
	fake.getScrollOffsetMutex.Lock()
	defer fake.getScrollOffsetMutex.Unlock()
	fake.GetScrollOffsetStub = nil
	if fake.getScrollOffsetReturnsOnCall == nil {
		fake.getScrollOffsetReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.getScrollOffsetReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeConversationRenderer) IsToolResultExpanded(arg1 int) bool {
	fake.isToolResultExpandedMutex.Lock()
	ret, specificReturn := fake.isToolResultExpandedReturnsOnCall[len(fake.isToolResultExpandedArgsForCall)]
	fake.isToolResultExpandedArgsForCall = append(fake.isToolResultExpandedArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.IsToolResultExpandedStub
	fakeReturns := fake.isToolResultExpandedReturns
	fake.recordInvocation("IsToolResultExpanded", []interface{}{arg1})
	fake.isToolResultExpandedMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConversationRenderer) IsToolResultExpandedCallCount() int {
	fake.isToolResultExpandedMutex.RLock()
	defer fake.isToolResultExpandedMutex.RUnlock()
	return len(fake.isToolResultExpandedArgsForCall)
}

func (fake *FakeConversationRenderer) IsToolResultExpandedCalls(stub func(int) bool) {
	fake.isToolResultExpandedMutex.Lock()
	defer fake.isToolResultExpandedMutex.Unlock()
	fake.IsToolResultExpandedStub = stub
}

func (fake *FakeConversationRenderer) IsToolResultExpandedArgsForCall(i int) int {
	fake.isToolResultExpandedMutex.RLock()
	defer fake.isToolResultExpandedMutex.RUnlock()
	argsForCall := fake.isToolResultExpandedArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConversationRenderer) IsToolResultExpandedReturns(result1 bool) {
	fake.isToolResultExpandedMutex.Lock()
	defer fake.isToolResultExpandedMutex.Unlock()
	fake.IsToolResultExpandedStub = nil
	fake.isToolResultExpandedReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConversationRenderer) IsToolResultExpandedReturnsOnCall(i int, result1 bool) {
	fake.isToolResultExpandedMutex.Lock()
	defer fake.isToolResultExpandedMutex.Unlock()
	fake.IsToolResultExpandedStub = nil
	if fake.isToolResultExpandedReturnsOnCall == nil {
		fake.isToolResultExpandedReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isToolResultExpandedReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeConversationRenderer) Render() string {
	fake.renderMutex.Lock()
	ret, specificReturn := fake.renderReturnsOnCall[len(fake.renderArgsForCall)]
	fake.renderArgsForCall = append(fake.renderArgsForCall, struct {
	}{})
	stub := fake.RenderStub
	fakeReturns := fake.renderReturns
	fake.recordInvocation("Render", []interface{}{})
	fake.renderMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeConversationRenderer) RenderCallCount() int {
	fake.renderMutex.RLock()
	defer fake.renderMutex.RUnlock()
	return len(fake.renderArgsForCall)
}

func (fake *FakeConversationRenderer) RenderCalls(stub func() string) {
	fake.renderMutex.Lock()
	defer fake.renderMutex.Unlock()
	fake.RenderStub = stub
}

func (fake *FakeConversationRenderer) RenderReturns(result1 string) {
	fake.renderMutex.Lock()
	defer fake.renderMutex.Unlock()
	fake.RenderStub = nil
	fake.renderReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeConversationRenderer) RenderReturnsOnCall(i int, result1 string) {
	fake.renderMutex.Lock()
	defer fake.renderMutex.Unlock()
	fake.RenderStub = nil
	if fake.renderReturnsOnCall == nil {
		fake.renderReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.renderReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeConversationRenderer) SetConversation(arg1 []domain.ConversationEntry) {
	var arg1Copy []domain.ConversationEntry
	if arg1 != nil {
		arg1Copy = make([]domain.ConversationEntry, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.setConversationMutex.Lock()
	fake.setConversationArgsForCall = append(fake.setConversationArgsForCall, struct {
		arg1 []domain.ConversationEntry
	}{arg1Copy})
	stub := fake.SetConversationStub
	fake.recordInvocation("SetConversation", []interface{}{arg1Copy})
	fake.setConversationMutex.Unlock()
	if stub != nil {
		fake.SetConversationStub(arg1)
	}
}

func (fake *FakeConversationRenderer) SetConversationCallCount() int {
	fake.setConversationMutex.RLock()
	defer fake.setConversationMutex.RUnlock()
	return len(fake.setConversationArgsForCall)
}

func (fake *FakeConversationRenderer) SetConversationCalls(stub func([]domain.ConversationEntry)) {
	fake.setConversationMutex.Lock()
	defer fake.setConversationMutex.Unlock()
	fake.SetConversationStub = stub
}

func (fake *FakeConversationRenderer) SetConversationArgsForCall(i int) []domain.ConversationEntry {
	fake.setConversationMutex.RLock()
	defer fake.setConversationMutex.RUnlock()
	argsForCall := fake.setConversationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConversationRenderer) SetHeight(arg1 int) {
	fake.setHeightMutex.Lock()
	fake.setHeightArgsForCall = append(fake.setHeightArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.SetHeightStub
	fake.recordInvocation("SetHeight", []interface{}{arg1})
	fake.setHeightMutex.Unlock()
	if stub != nil {
		fake.SetHeightStub(arg1)
	}
}

func (fake *FakeConversationRenderer) SetHeightCallCount() int {
	fake.setHeightMutex.RLock()
	defer fake.setHeightMutex.RUnlock()
	return len(fake.setHeightArgsForCall)
}

func (fake *FakeConversationRenderer) SetHeightCalls(stub func(int)) {
	fake.setHeightMutex.Lock()
	defer fake.setHeightMutex.Unlock()
	fake.SetHeightStub = stub
}

func (fake *FakeConversationRenderer) SetHeightArgsForCall(i int) int {
	fake.setHeightMutex.RLock()
	defer fake.setHeightMutex.RUnlock()
	argsForCall := fake.setHeightArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConversationRenderer) SetWidth(arg1 int) {
	fake.setWidthMutex.Lock()
	fake.setWidthArgsForCall = append(fake.setWidthArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.SetWidthStub
	fake.recordInvocation("SetWidth", []interface{}{arg1})
	fake.setWidthMutex.Unlock()
	if stub != nil {
		fake.SetWidthStub(arg1)
	}
}

func (fake *FakeConversationRenderer) SetWidthCallCount() int {
	fake.setWidthMutex.RLock()
	defer fake.setWidthMutex.RUnlock()
	return len(fake.setWidthArgsForCall)
}

func (fake *FakeConversationRenderer) SetWidthCalls(stub func(int)) {
	fake.setWidthMutex.Lock()
	defer fake.setWidthMutex.Unlock()
	fake.SetWidthStub = stub
}

func (fake *FakeConversationRenderer) SetWidthArgsForCall(i int) int {
	fake.setWidthMutex.RLock()
	defer fake.setWidthMutex.RUnlock()
	argsForCall := fake.setWidthArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConversationRenderer) ToggleAllToolResultsExpansion() {
	fake.toggleAllToolResultsExpansionMutex.Lock()
	fake.toggleAllToolResultsExpansionArgsForCall = append(fake.toggleAllToolResultsExpansionArgsForCall, struct {
	}{})
	stub := fake.ToggleAllToolResultsExpansionStub
	fake.recordInvocation("ToggleAllToolResultsExpansion", []interface{}{})
	fake.toggleAllToolResultsExpansionMutex.Unlock()
	if stub != nil {
		fake.ToggleAllToolResultsExpansionStub()
	}
}

func (fake *FakeConversationRenderer) ToggleAllToolResultsExpansionCallCount() int {
	fake.toggleAllToolResultsExpansionMutex.RLock()
	defer fake.toggleAllToolResultsExpansionMutex.RUnlock()
	return len(fake.toggleAllToolResultsExpansionArgsForCall)
}

func (fake *FakeConversationRenderer) ToggleAllToolResultsExpansionCalls(stub func()) {
	fake.toggleAllToolResultsExpansionMutex.Lock()
	defer fake.toggleAllToolResultsExpansionMutex.Unlock()
	fake.ToggleAllToolResultsExpansionStub = stub
}

func (fake *FakeConversationRenderer) ToggleToolResultExpansion(arg1 int) {
	fake.toggleToolResultExpansionMutex.Lock()
	fake.toggleToolResultExpansionArgsForCall = append(fake.toggleToolResultExpansionArgsForCall, struct {
		arg1 int
	}{arg1})
	stub := fake.ToggleToolResultExpansionStub
	fake.recordInvocation("ToggleToolResultExpansion", []interface{}{arg1})
	fake.toggleToolResultExpansionMutex.Unlock()
	if stub != nil {
		fake.ToggleToolResultExpansionStub(arg1)
	}
}

func (fake *FakeConversationRenderer) ToggleToolResultExpansionCallCount() int {
	fake.toggleToolResultExpansionMutex.RLock()
	defer fake.toggleToolResultExpansionMutex.RUnlock()
	return len(fake.toggleToolResultExpansionArgsForCall)
}

func (fake *FakeConversationRenderer) ToggleToolResultExpansionCalls(stub func(int)) {
	fake.toggleToolResultExpansionMutex.Lock()
	defer fake.toggleToolResultExpansionMutex.Unlock()
	fake.ToggleToolResultExpansionStub = stub
}

func (fake *FakeConversationRenderer) ToggleToolResultExpansionArgsForCall(i int) int {
	fake.toggleToolResultExpansionMutex.RLock()
	defer fake.toggleToolResultExpansionMutex.RUnlock()
	argsForCall := fake.toggleToolResultExpansionArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeConversationRenderer) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeConversationRenderer) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ ui.ConversationRenderer = new(FakeConversationRenderer)
