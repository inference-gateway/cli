// Code generated by counterfeiter. DO NOT EDIT.
package generated

import (
	"context"
	"sync"

	"github.com/inference-gateway/cli/internal/domain"
	"github.com/inference-gateway/sdk"
)

type FakeToolService struct {
	ExecuteToolStub        func(context.Context, sdk.ChatCompletionMessageToolCallFunction) (*domain.ToolExecutionResult, error)
	executeToolMutex       sync.RWMutex
	executeToolArgsForCall []struct {
		arg1 context.Context
		arg2 sdk.ChatCompletionMessageToolCallFunction
	}
	executeToolReturns struct {
		result1 *domain.ToolExecutionResult
		result2 error
	}
	executeToolReturnsOnCall map[int]struct {
		result1 *domain.ToolExecutionResult
		result2 error
	}
	ExecuteToolDirectStub        func(context.Context, sdk.ChatCompletionMessageToolCallFunction) (*domain.ToolExecutionResult, error)
	executeToolDirectMutex       sync.RWMutex
	executeToolDirectArgsForCall []struct {
		arg1 context.Context
		arg2 sdk.ChatCompletionMessageToolCallFunction
	}
	executeToolDirectReturns struct {
		result1 *domain.ToolExecutionResult
		result2 error
	}
	executeToolDirectReturnsOnCall map[int]struct {
		result1 *domain.ToolExecutionResult
		result2 error
	}
	GetTaskTrackerStub        func() domain.TaskTracker
	getTaskTrackerMutex       sync.RWMutex
	getTaskTrackerArgsForCall []struct {
	}
	getTaskTrackerReturns struct {
		result1 domain.TaskTracker
	}
	getTaskTrackerReturnsOnCall map[int]struct {
		result1 domain.TaskTracker
	}
	IsToolEnabledStub        func(string) bool
	isToolEnabledMutex       sync.RWMutex
	isToolEnabledArgsForCall []struct {
		arg1 string
	}
	isToolEnabledReturns struct {
		result1 bool
	}
	isToolEnabledReturnsOnCall map[int]struct {
		result1 bool
	}
	ListAvailableToolsStub        func() []string
	listAvailableToolsMutex       sync.RWMutex
	listAvailableToolsArgsForCall []struct {
	}
	listAvailableToolsReturns struct {
		result1 []string
	}
	listAvailableToolsReturnsOnCall map[int]struct {
		result1 []string
	}
	ListToolsStub        func() []sdk.ChatCompletionTool
	listToolsMutex       sync.RWMutex
	listToolsArgsForCall []struct {
	}
	listToolsReturns struct {
		result1 []sdk.ChatCompletionTool
	}
	listToolsReturnsOnCall map[int]struct {
		result1 []sdk.ChatCompletionTool
	}
	ListToolsForModeStub        func(domain.AgentMode) []sdk.ChatCompletionTool
	listToolsForModeMutex       sync.RWMutex
	listToolsForModeArgsForCall []struct {
		arg1 domain.AgentMode
	}
	listToolsForModeReturns struct {
		result1 []sdk.ChatCompletionTool
	}
	listToolsForModeReturnsOnCall map[int]struct {
		result1 []sdk.ChatCompletionTool
	}
	ValidateToolStub        func(string, map[string]any) error
	validateToolMutex       sync.RWMutex
	validateToolArgsForCall []struct {
		arg1 string
		arg2 map[string]any
	}
	validateToolReturns struct {
		result1 error
	}
	validateToolReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeToolService) ExecuteTool(arg1 context.Context, arg2 sdk.ChatCompletionMessageToolCallFunction) (*domain.ToolExecutionResult, error) {
	fake.executeToolMutex.Lock()
	ret, specificReturn := fake.executeToolReturnsOnCall[len(fake.executeToolArgsForCall)]
	fake.executeToolArgsForCall = append(fake.executeToolArgsForCall, struct {
		arg1 context.Context
		arg2 sdk.ChatCompletionMessageToolCallFunction
	}{arg1, arg2})
	stub := fake.ExecuteToolStub
	fakeReturns := fake.executeToolReturns
	fake.recordInvocation("ExecuteTool", []interface{}{arg1, arg2})
	fake.executeToolMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeToolService) ExecuteToolCallCount() int {
	fake.executeToolMutex.RLock()
	defer fake.executeToolMutex.RUnlock()
	return len(fake.executeToolArgsForCall)
}

func (fake *FakeToolService) ExecuteToolCalls(stub func(context.Context, sdk.ChatCompletionMessageToolCallFunction) (*domain.ToolExecutionResult, error)) {
	fake.executeToolMutex.Lock()
	defer fake.executeToolMutex.Unlock()
	fake.ExecuteToolStub = stub
}

func (fake *FakeToolService) ExecuteToolArgsForCall(i int) (context.Context, sdk.ChatCompletionMessageToolCallFunction) {
	fake.executeToolMutex.RLock()
	defer fake.executeToolMutex.RUnlock()
	argsForCall := fake.executeToolArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeToolService) ExecuteToolReturns(result1 *domain.ToolExecutionResult, result2 error) {
	fake.executeToolMutex.Lock()
	defer fake.executeToolMutex.Unlock()
	fake.ExecuteToolStub = nil
	fake.executeToolReturns = struct {
		result1 *domain.ToolExecutionResult
		result2 error
	}{result1, result2}
}

func (fake *FakeToolService) ExecuteToolReturnsOnCall(i int, result1 *domain.ToolExecutionResult, result2 error) {
	fake.executeToolMutex.Lock()
	defer fake.executeToolMutex.Unlock()
	fake.ExecuteToolStub = nil
	if fake.executeToolReturnsOnCall == nil {
		fake.executeToolReturnsOnCall = make(map[int]struct {
			result1 *domain.ToolExecutionResult
			result2 error
		})
	}
	fake.executeToolReturnsOnCall[i] = struct {
		result1 *domain.ToolExecutionResult
		result2 error
	}{result1, result2}
}

func (fake *FakeToolService) ExecuteToolDirect(arg1 context.Context, arg2 sdk.ChatCompletionMessageToolCallFunction) (*domain.ToolExecutionResult, error) {
	fake.executeToolDirectMutex.Lock()
	ret, specificReturn := fake.executeToolDirectReturnsOnCall[len(fake.executeToolDirectArgsForCall)]
	fake.executeToolDirectArgsForCall = append(fake.executeToolDirectArgsForCall, struct {
		arg1 context.Context
		arg2 sdk.ChatCompletionMessageToolCallFunction
	}{arg1, arg2})
	stub := fake.ExecuteToolDirectStub
	fakeReturns := fake.executeToolDirectReturns
	fake.recordInvocation("ExecuteToolDirect", []interface{}{arg1, arg2})
	fake.executeToolDirectMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeToolService) ExecuteToolDirectCallCount() int {
	fake.executeToolDirectMutex.RLock()
	defer fake.executeToolDirectMutex.RUnlock()
	return len(fake.executeToolDirectArgsForCall)
}

func (fake *FakeToolService) ExecuteToolDirectCalls(stub func(context.Context, sdk.ChatCompletionMessageToolCallFunction) (*domain.ToolExecutionResult, error)) {
	fake.executeToolDirectMutex.Lock()
	defer fake.executeToolDirectMutex.Unlock()
	fake.ExecuteToolDirectStub = stub
}

func (fake *FakeToolService) ExecuteToolDirectArgsForCall(i int) (context.Context, sdk.ChatCompletionMessageToolCallFunction) {
	fake.executeToolDirectMutex.RLock()
	defer fake.executeToolDirectMutex.RUnlock()
	argsForCall := fake.executeToolDirectArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeToolService) ExecuteToolDirectReturns(result1 *domain.ToolExecutionResult, result2 error) {
	fake.executeToolDirectMutex.Lock()
	defer fake.executeToolDirectMutex.Unlock()
	fake.ExecuteToolDirectStub = nil
	fake.executeToolDirectReturns = struct {
		result1 *domain.ToolExecutionResult
		result2 error
	}{result1, result2}
}

func (fake *FakeToolService) ExecuteToolDirectReturnsOnCall(i int, result1 *domain.ToolExecutionResult, result2 error) {
	fake.executeToolDirectMutex.Lock()
	defer fake.executeToolDirectMutex.Unlock()
	fake.ExecuteToolDirectStub = nil
	if fake.executeToolDirectReturnsOnCall == nil {
		fake.executeToolDirectReturnsOnCall = make(map[int]struct {
			result1 *domain.ToolExecutionResult
			result2 error
		})
	}
	fake.executeToolDirectReturnsOnCall[i] = struct {
		result1 *domain.ToolExecutionResult
		result2 error
	}{result1, result2}
}

func (fake *FakeToolService) GetTaskTracker() domain.TaskTracker {
	fake.getTaskTrackerMutex.Lock()
	ret, specificReturn := fake.getTaskTrackerReturnsOnCall[len(fake.getTaskTrackerArgsForCall)]
	fake.getTaskTrackerArgsForCall = append(fake.getTaskTrackerArgsForCall, struct {
	}{})
	stub := fake.GetTaskTrackerStub
	fakeReturns := fake.getTaskTrackerReturns
	fake.recordInvocation("GetTaskTracker", []interface{}{})
	fake.getTaskTrackerMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolService) GetTaskTrackerCallCount() int {
	fake.getTaskTrackerMutex.RLock()
	defer fake.getTaskTrackerMutex.RUnlock()
	return len(fake.getTaskTrackerArgsForCall)
}

func (fake *FakeToolService) GetTaskTrackerCalls(stub func() domain.TaskTracker) {
	fake.getTaskTrackerMutex.Lock()
	defer fake.getTaskTrackerMutex.Unlock()
	fake.GetTaskTrackerStub = stub
}

func (fake *FakeToolService) GetTaskTrackerReturns(result1 domain.TaskTracker) {
	fake.getTaskTrackerMutex.Lock()
	defer fake.getTaskTrackerMutex.Unlock()
	fake.GetTaskTrackerStub = nil
	fake.getTaskTrackerReturns = struct {
		result1 domain.TaskTracker
	}{result1}
}

func (fake *FakeToolService) GetTaskTrackerReturnsOnCall(i int, result1 domain.TaskTracker) {
	fake.getTaskTrackerMutex.Lock()
	defer fake.getTaskTrackerMutex.Unlock()
	fake.GetTaskTrackerStub = nil
	if fake.getTaskTrackerReturnsOnCall == nil {
		fake.getTaskTrackerReturnsOnCall = make(map[int]struct {
			result1 domain.TaskTracker
		})
	}
	fake.getTaskTrackerReturnsOnCall[i] = struct {
		result1 domain.TaskTracker
	}{result1}
}

func (fake *FakeToolService) IsToolEnabled(arg1 string) bool {
	fake.isToolEnabledMutex.Lock()
	ret, specificReturn := fake.isToolEnabledReturnsOnCall[len(fake.isToolEnabledArgsForCall)]
	fake.isToolEnabledArgsForCall = append(fake.isToolEnabledArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsToolEnabledStub
	fakeReturns := fake.isToolEnabledReturns
	fake.recordInvocation("IsToolEnabled", []interface{}{arg1})
	fake.isToolEnabledMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolService) IsToolEnabledCallCount() int {
	fake.isToolEnabledMutex.RLock()
	defer fake.isToolEnabledMutex.RUnlock()
	return len(fake.isToolEnabledArgsForCall)
}

func (fake *FakeToolService) IsToolEnabledCalls(stub func(string) bool) {
	fake.isToolEnabledMutex.Lock()
	defer fake.isToolEnabledMutex.Unlock()
	fake.IsToolEnabledStub = stub
}

func (fake *FakeToolService) IsToolEnabledArgsForCall(i int) string {
	fake.isToolEnabledMutex.RLock()
	defer fake.isToolEnabledMutex.RUnlock()
	argsForCall := fake.isToolEnabledArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolService) IsToolEnabledReturns(result1 bool) {
	fake.isToolEnabledMutex.Lock()
	defer fake.isToolEnabledMutex.Unlock()
	fake.IsToolEnabledStub = nil
	fake.isToolEnabledReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeToolService) IsToolEnabledReturnsOnCall(i int, result1 bool) {
	fake.isToolEnabledMutex.Lock()
	defer fake.isToolEnabledMutex.Unlock()
	fake.IsToolEnabledStub = nil
	if fake.isToolEnabledReturnsOnCall == nil {
		fake.isToolEnabledReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isToolEnabledReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeToolService) ListAvailableTools() []string {
	fake.listAvailableToolsMutex.Lock()
	ret, specificReturn := fake.listAvailableToolsReturnsOnCall[len(fake.listAvailableToolsArgsForCall)]
	fake.listAvailableToolsArgsForCall = append(fake.listAvailableToolsArgsForCall, struct {
	}{})
	stub := fake.ListAvailableToolsStub
	fakeReturns := fake.listAvailableToolsReturns
	fake.recordInvocation("ListAvailableTools", []interface{}{})
	fake.listAvailableToolsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolService) ListAvailableToolsCallCount() int {
	fake.listAvailableToolsMutex.RLock()
	defer fake.listAvailableToolsMutex.RUnlock()
	return len(fake.listAvailableToolsArgsForCall)
}

func (fake *FakeToolService) ListAvailableToolsCalls(stub func() []string) {
	fake.listAvailableToolsMutex.Lock()
	defer fake.listAvailableToolsMutex.Unlock()
	fake.ListAvailableToolsStub = stub
}

func (fake *FakeToolService) ListAvailableToolsReturns(result1 []string) {
	fake.listAvailableToolsMutex.Lock()
	defer fake.listAvailableToolsMutex.Unlock()
	fake.ListAvailableToolsStub = nil
	fake.listAvailableToolsReturns = struct {
		result1 []string
	}{result1}
}

func (fake *FakeToolService) ListAvailableToolsReturnsOnCall(i int, result1 []string) {
	fake.listAvailableToolsMutex.Lock()
	defer fake.listAvailableToolsMutex.Unlock()
	fake.ListAvailableToolsStub = nil
	if fake.listAvailableToolsReturnsOnCall == nil {
		fake.listAvailableToolsReturnsOnCall = make(map[int]struct {
			result1 []string
		})
	}
	fake.listAvailableToolsReturnsOnCall[i] = struct {
		result1 []string
	}{result1}
}

func (fake *FakeToolService) ListTools() []sdk.ChatCompletionTool {
	fake.listToolsMutex.Lock()
	ret, specificReturn := fake.listToolsReturnsOnCall[len(fake.listToolsArgsForCall)]
	fake.listToolsArgsForCall = append(fake.listToolsArgsForCall, struct {
	}{})
	stub := fake.ListToolsStub
	fakeReturns := fake.listToolsReturns
	fake.recordInvocation("ListTools", []interface{}{})
	fake.listToolsMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolService) ListToolsCallCount() int {
	fake.listToolsMutex.RLock()
	defer fake.listToolsMutex.RUnlock()
	return len(fake.listToolsArgsForCall)
}

func (fake *FakeToolService) ListToolsCalls(stub func() []sdk.ChatCompletionTool) {
	fake.listToolsMutex.Lock()
	defer fake.listToolsMutex.Unlock()
	fake.ListToolsStub = stub
}

func (fake *FakeToolService) ListToolsReturns(result1 []sdk.ChatCompletionTool) {
	fake.listToolsMutex.Lock()
	defer fake.listToolsMutex.Unlock()
	fake.ListToolsStub = nil
	fake.listToolsReturns = struct {
		result1 []sdk.ChatCompletionTool
	}{result1}
}

func (fake *FakeToolService) ListToolsReturnsOnCall(i int, result1 []sdk.ChatCompletionTool) {
	fake.listToolsMutex.Lock()
	defer fake.listToolsMutex.Unlock()
	fake.ListToolsStub = nil
	if fake.listToolsReturnsOnCall == nil {
		fake.listToolsReturnsOnCall = make(map[int]struct {
			result1 []sdk.ChatCompletionTool
		})
	}
	fake.listToolsReturnsOnCall[i] = struct {
		result1 []sdk.ChatCompletionTool
	}{result1}
}

func (fake *FakeToolService) ListToolsForMode(arg1 domain.AgentMode) []sdk.ChatCompletionTool {
	fake.listToolsForModeMutex.Lock()
	ret, specificReturn := fake.listToolsForModeReturnsOnCall[len(fake.listToolsForModeArgsForCall)]
	fake.listToolsForModeArgsForCall = append(fake.listToolsForModeArgsForCall, struct {
		arg1 domain.AgentMode
	}{arg1})
	stub := fake.ListToolsForModeStub
	fakeReturns := fake.listToolsForModeReturns
	fake.recordInvocation("ListToolsForMode", []interface{}{arg1})
	fake.listToolsForModeMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolService) ListToolsForModeCallCount() int {
	fake.listToolsForModeMutex.RLock()
	defer fake.listToolsForModeMutex.RUnlock()
	return len(fake.listToolsForModeArgsForCall)
}

func (fake *FakeToolService) ListToolsForModeCalls(stub func(domain.AgentMode) []sdk.ChatCompletionTool) {
	fake.listToolsForModeMutex.Lock()
	defer fake.listToolsForModeMutex.Unlock()
	fake.ListToolsForModeStub = stub
}

func (fake *FakeToolService) ListToolsForModeArgsForCall(i int) domain.AgentMode {
	fake.listToolsForModeMutex.RLock()
	defer fake.listToolsForModeMutex.RUnlock()
	argsForCall := fake.listToolsForModeArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeToolService) ListToolsForModeReturns(result1 []sdk.ChatCompletionTool) {
	fake.listToolsForModeMutex.Lock()
	defer fake.listToolsForModeMutex.Unlock()
	fake.ListToolsForModeStub = nil
	fake.listToolsForModeReturns = struct {
		result1 []sdk.ChatCompletionTool
	}{result1}
}

func (fake *FakeToolService) ListToolsForModeReturnsOnCall(i int, result1 []sdk.ChatCompletionTool) {
	fake.listToolsForModeMutex.Lock()
	defer fake.listToolsForModeMutex.Unlock()
	fake.ListToolsForModeStub = nil
	if fake.listToolsForModeReturnsOnCall == nil {
		fake.listToolsForModeReturnsOnCall = make(map[int]struct {
			result1 []sdk.ChatCompletionTool
		})
	}
	fake.listToolsForModeReturnsOnCall[i] = struct {
		result1 []sdk.ChatCompletionTool
	}{result1}
}

func (fake *FakeToolService) ValidateTool(arg1 string, arg2 map[string]any) error {
	fake.validateToolMutex.Lock()
	ret, specificReturn := fake.validateToolReturnsOnCall[len(fake.validateToolArgsForCall)]
	fake.validateToolArgsForCall = append(fake.validateToolArgsForCall, struct {
		arg1 string
		arg2 map[string]any
	}{arg1, arg2})
	stub := fake.ValidateToolStub
	fakeReturns := fake.validateToolReturns
	fake.recordInvocation("ValidateTool", []interface{}{arg1, arg2})
	fake.validateToolMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeToolService) ValidateToolCallCount() int {
	fake.validateToolMutex.RLock()
	defer fake.validateToolMutex.RUnlock()
	return len(fake.validateToolArgsForCall)
}

func (fake *FakeToolService) ValidateToolCalls(stub func(string, map[string]any) error) {
	fake.validateToolMutex.Lock()
	defer fake.validateToolMutex.Unlock()
	fake.ValidateToolStub = stub
}

func (fake *FakeToolService) ValidateToolArgsForCall(i int) (string, map[string]any) {
	fake.validateToolMutex.RLock()
	defer fake.validateToolMutex.RUnlock()
	argsForCall := fake.validateToolArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeToolService) ValidateToolReturns(result1 error) {
	fake.validateToolMutex.Lock()
	defer fake.validateToolMutex.Unlock()
	fake.ValidateToolStub = nil
	fake.validateToolReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolService) ValidateToolReturnsOnCall(i int, result1 error) {
	fake.validateToolMutex.Lock()
	defer fake.validateToolMutex.Unlock()
	fake.ValidateToolStub = nil
	if fake.validateToolReturnsOnCall == nil {
		fake.validateToolReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.validateToolReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeToolService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeToolService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ domain.ToolService = new(FakeToolService)
