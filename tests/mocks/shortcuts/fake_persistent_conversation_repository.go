// Code generated by counterfeiter. DO NOT EDIT.
package shortcuts

import (
	"context"
	"sync"

	"github.com/inference-gateway/cli/internal/shortcuts"
)

type FakePersistentConversationRepository struct {
	DeleteSavedConversationStub        func(context.Context, string) error
	deleteSavedConversationMutex       sync.RWMutex
	deleteSavedConversationArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteSavedConversationReturns struct {
		result1 error
	}
	deleteSavedConversationReturnsOnCall map[int]struct {
		result1 error
	}
	GetCurrentConversationIDStub        func() string
	getCurrentConversationIDMutex       sync.RWMutex
	getCurrentConversationIDArgsForCall []struct {
	}
	getCurrentConversationIDReturns struct {
		result1 string
	}
	getCurrentConversationIDReturnsOnCall map[int]struct {
		result1 string
	}
	GetCurrentConversationMetadataStub        func() shortcuts.ConversationMetadata
	getCurrentConversationMetadataMutex       sync.RWMutex
	getCurrentConversationMetadataArgsForCall []struct {
	}
	getCurrentConversationMetadataReturns struct {
		result1 shortcuts.ConversationMetadata
	}
	getCurrentConversationMetadataReturnsOnCall map[int]struct {
		result1 shortcuts.ConversationMetadata
	}
	ListSavedConversationsStub        func(context.Context, int, int) ([]shortcuts.ConversationSummary, error)
	listSavedConversationsMutex       sync.RWMutex
	listSavedConversationsArgsForCall []struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}
	listSavedConversationsReturns struct {
		result1 []shortcuts.ConversationSummary
		result2 error
	}
	listSavedConversationsReturnsOnCall map[int]struct {
		result1 []shortcuts.ConversationSummary
		result2 error
	}
	LoadConversationStub        func(context.Context, string) error
	loadConversationMutex       sync.RWMutex
	loadConversationArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	loadConversationReturns struct {
		result1 error
	}
	loadConversationReturnsOnCall map[int]struct {
		result1 error
	}
	SaveConversationStub        func(context.Context) error
	saveConversationMutex       sync.RWMutex
	saveConversationArgsForCall []struct {
		arg1 context.Context
	}
	saveConversationReturns struct {
		result1 error
	}
	saveConversationReturnsOnCall map[int]struct {
		result1 error
	}
	SetConversationTitleStub        func(string)
	setConversationTitleMutex       sync.RWMutex
	setConversationTitleArgsForCall []struct {
		arg1 string
	}
	StartNewConversationStub        func(string) error
	startNewConversationMutex       sync.RWMutex
	startNewConversationArgsForCall []struct {
		arg1 string
	}
	startNewConversationReturns struct {
		result1 error
	}
	startNewConversationReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakePersistentConversationRepository) DeleteSavedConversation(arg1 context.Context, arg2 string) error {
	fake.deleteSavedConversationMutex.Lock()
	ret, specificReturn := fake.deleteSavedConversationReturnsOnCall[len(fake.deleteSavedConversationArgsForCall)]
	fake.deleteSavedConversationArgsForCall = append(fake.deleteSavedConversationArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteSavedConversationStub
	fakeReturns := fake.deleteSavedConversationReturns
	fake.recordInvocation("DeleteSavedConversation", []interface{}{arg1, arg2})
	fake.deleteSavedConversationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePersistentConversationRepository) DeleteSavedConversationCallCount() int {
	fake.deleteSavedConversationMutex.RLock()
	defer fake.deleteSavedConversationMutex.RUnlock()
	return len(fake.deleteSavedConversationArgsForCall)
}

func (fake *FakePersistentConversationRepository) DeleteSavedConversationCalls(stub func(context.Context, string) error) {
	fake.deleteSavedConversationMutex.Lock()
	defer fake.deleteSavedConversationMutex.Unlock()
	fake.DeleteSavedConversationStub = stub
}

func (fake *FakePersistentConversationRepository) DeleteSavedConversationArgsForCall(i int) (context.Context, string) {
	fake.deleteSavedConversationMutex.RLock()
	defer fake.deleteSavedConversationMutex.RUnlock()
	argsForCall := fake.deleteSavedConversationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistentConversationRepository) DeleteSavedConversationReturns(result1 error) {
	fake.deleteSavedConversationMutex.Lock()
	defer fake.deleteSavedConversationMutex.Unlock()
	fake.DeleteSavedConversationStub = nil
	fake.deleteSavedConversationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistentConversationRepository) DeleteSavedConversationReturnsOnCall(i int, result1 error) {
	fake.deleteSavedConversationMutex.Lock()
	defer fake.deleteSavedConversationMutex.Unlock()
	fake.DeleteSavedConversationStub = nil
	if fake.deleteSavedConversationReturnsOnCall == nil {
		fake.deleteSavedConversationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteSavedConversationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistentConversationRepository) GetCurrentConversationID() string {
	fake.getCurrentConversationIDMutex.Lock()
	ret, specificReturn := fake.getCurrentConversationIDReturnsOnCall[len(fake.getCurrentConversationIDArgsForCall)]
	fake.getCurrentConversationIDArgsForCall = append(fake.getCurrentConversationIDArgsForCall, struct {
	}{})
	stub := fake.GetCurrentConversationIDStub
	fakeReturns := fake.getCurrentConversationIDReturns
	fake.recordInvocation("GetCurrentConversationID", []interface{}{})
	fake.getCurrentConversationIDMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePersistentConversationRepository) GetCurrentConversationIDCallCount() int {
	fake.getCurrentConversationIDMutex.RLock()
	defer fake.getCurrentConversationIDMutex.RUnlock()
	return len(fake.getCurrentConversationIDArgsForCall)
}

func (fake *FakePersistentConversationRepository) GetCurrentConversationIDCalls(stub func() string) {
	fake.getCurrentConversationIDMutex.Lock()
	defer fake.getCurrentConversationIDMutex.Unlock()
	fake.GetCurrentConversationIDStub = stub
}

func (fake *FakePersistentConversationRepository) GetCurrentConversationIDReturns(result1 string) {
	fake.getCurrentConversationIDMutex.Lock()
	defer fake.getCurrentConversationIDMutex.Unlock()
	fake.GetCurrentConversationIDStub = nil
	fake.getCurrentConversationIDReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakePersistentConversationRepository) GetCurrentConversationIDReturnsOnCall(i int, result1 string) {
	fake.getCurrentConversationIDMutex.Lock()
	defer fake.getCurrentConversationIDMutex.Unlock()
	fake.GetCurrentConversationIDStub = nil
	if fake.getCurrentConversationIDReturnsOnCall == nil {
		fake.getCurrentConversationIDReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.getCurrentConversationIDReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakePersistentConversationRepository) GetCurrentConversationMetadata() shortcuts.ConversationMetadata {
	fake.getCurrentConversationMetadataMutex.Lock()
	ret, specificReturn := fake.getCurrentConversationMetadataReturnsOnCall[len(fake.getCurrentConversationMetadataArgsForCall)]
	fake.getCurrentConversationMetadataArgsForCall = append(fake.getCurrentConversationMetadataArgsForCall, struct {
	}{})
	stub := fake.GetCurrentConversationMetadataStub
	fakeReturns := fake.getCurrentConversationMetadataReturns
	fake.recordInvocation("GetCurrentConversationMetadata", []interface{}{})
	fake.getCurrentConversationMetadataMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePersistentConversationRepository) GetCurrentConversationMetadataCallCount() int {
	fake.getCurrentConversationMetadataMutex.RLock()
	defer fake.getCurrentConversationMetadataMutex.RUnlock()
	return len(fake.getCurrentConversationMetadataArgsForCall)
}

func (fake *FakePersistentConversationRepository) GetCurrentConversationMetadataCalls(stub func() shortcuts.ConversationMetadata) {
	fake.getCurrentConversationMetadataMutex.Lock()
	defer fake.getCurrentConversationMetadataMutex.Unlock()
	fake.GetCurrentConversationMetadataStub = stub
}

func (fake *FakePersistentConversationRepository) GetCurrentConversationMetadataReturns(result1 shortcuts.ConversationMetadata) {
	fake.getCurrentConversationMetadataMutex.Lock()
	defer fake.getCurrentConversationMetadataMutex.Unlock()
	fake.GetCurrentConversationMetadataStub = nil
	fake.getCurrentConversationMetadataReturns = struct {
		result1 shortcuts.ConversationMetadata
	}{result1}
}

func (fake *FakePersistentConversationRepository) GetCurrentConversationMetadataReturnsOnCall(i int, result1 shortcuts.ConversationMetadata) {
	fake.getCurrentConversationMetadataMutex.Lock()
	defer fake.getCurrentConversationMetadataMutex.Unlock()
	fake.GetCurrentConversationMetadataStub = nil
	if fake.getCurrentConversationMetadataReturnsOnCall == nil {
		fake.getCurrentConversationMetadataReturnsOnCall = make(map[int]struct {
			result1 shortcuts.ConversationMetadata
		})
	}
	fake.getCurrentConversationMetadataReturnsOnCall[i] = struct {
		result1 shortcuts.ConversationMetadata
	}{result1}
}

func (fake *FakePersistentConversationRepository) ListSavedConversations(arg1 context.Context, arg2 int, arg3 int) ([]shortcuts.ConversationSummary, error) {
	fake.listSavedConversationsMutex.Lock()
	ret, specificReturn := fake.listSavedConversationsReturnsOnCall[len(fake.listSavedConversationsArgsForCall)]
	fake.listSavedConversationsArgsForCall = append(fake.listSavedConversationsArgsForCall, struct {
		arg1 context.Context
		arg2 int
		arg3 int
	}{arg1, arg2, arg3})
	stub := fake.ListSavedConversationsStub
	fakeReturns := fake.listSavedConversationsReturns
	fake.recordInvocation("ListSavedConversations", []interface{}{arg1, arg2, arg3})
	fake.listSavedConversationsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakePersistentConversationRepository) ListSavedConversationsCallCount() int {
	fake.listSavedConversationsMutex.RLock()
	defer fake.listSavedConversationsMutex.RUnlock()
	return len(fake.listSavedConversationsArgsForCall)
}

func (fake *FakePersistentConversationRepository) ListSavedConversationsCalls(stub func(context.Context, int, int) ([]shortcuts.ConversationSummary, error)) {
	fake.listSavedConversationsMutex.Lock()
	defer fake.listSavedConversationsMutex.Unlock()
	fake.ListSavedConversationsStub = stub
}

func (fake *FakePersistentConversationRepository) ListSavedConversationsArgsForCall(i int) (context.Context, int, int) {
	fake.listSavedConversationsMutex.RLock()
	defer fake.listSavedConversationsMutex.RUnlock()
	argsForCall := fake.listSavedConversationsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakePersistentConversationRepository) ListSavedConversationsReturns(result1 []shortcuts.ConversationSummary, result2 error) {
	fake.listSavedConversationsMutex.Lock()
	defer fake.listSavedConversationsMutex.Unlock()
	fake.ListSavedConversationsStub = nil
	fake.listSavedConversationsReturns = struct {
		result1 []shortcuts.ConversationSummary
		result2 error
	}{result1, result2}
}

func (fake *FakePersistentConversationRepository) ListSavedConversationsReturnsOnCall(i int, result1 []shortcuts.ConversationSummary, result2 error) {
	fake.listSavedConversationsMutex.Lock()
	defer fake.listSavedConversationsMutex.Unlock()
	fake.ListSavedConversationsStub = nil
	if fake.listSavedConversationsReturnsOnCall == nil {
		fake.listSavedConversationsReturnsOnCall = make(map[int]struct {
			result1 []shortcuts.ConversationSummary
			result2 error
		})
	}
	fake.listSavedConversationsReturnsOnCall[i] = struct {
		result1 []shortcuts.ConversationSummary
		result2 error
	}{result1, result2}
}

func (fake *FakePersistentConversationRepository) LoadConversation(arg1 context.Context, arg2 string) error {
	fake.loadConversationMutex.Lock()
	ret, specificReturn := fake.loadConversationReturnsOnCall[len(fake.loadConversationArgsForCall)]
	fake.loadConversationArgsForCall = append(fake.loadConversationArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.LoadConversationStub
	fakeReturns := fake.loadConversationReturns
	fake.recordInvocation("LoadConversation", []interface{}{arg1, arg2})
	fake.loadConversationMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePersistentConversationRepository) LoadConversationCallCount() int {
	fake.loadConversationMutex.RLock()
	defer fake.loadConversationMutex.RUnlock()
	return len(fake.loadConversationArgsForCall)
}

func (fake *FakePersistentConversationRepository) LoadConversationCalls(stub func(context.Context, string) error) {
	fake.loadConversationMutex.Lock()
	defer fake.loadConversationMutex.Unlock()
	fake.LoadConversationStub = stub
}

func (fake *FakePersistentConversationRepository) LoadConversationArgsForCall(i int) (context.Context, string) {
	fake.loadConversationMutex.RLock()
	defer fake.loadConversationMutex.RUnlock()
	argsForCall := fake.loadConversationArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakePersistentConversationRepository) LoadConversationReturns(result1 error) {
	fake.loadConversationMutex.Lock()
	defer fake.loadConversationMutex.Unlock()
	fake.LoadConversationStub = nil
	fake.loadConversationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistentConversationRepository) LoadConversationReturnsOnCall(i int, result1 error) {
	fake.loadConversationMutex.Lock()
	defer fake.loadConversationMutex.Unlock()
	fake.LoadConversationStub = nil
	if fake.loadConversationReturnsOnCall == nil {
		fake.loadConversationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.loadConversationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistentConversationRepository) SaveConversation(arg1 context.Context) error {
	fake.saveConversationMutex.Lock()
	ret, specificReturn := fake.saveConversationReturnsOnCall[len(fake.saveConversationArgsForCall)]
	fake.saveConversationArgsForCall = append(fake.saveConversationArgsForCall, struct {
		arg1 context.Context
	}{arg1})
	stub := fake.SaveConversationStub
	fakeReturns := fake.saveConversationReturns
	fake.recordInvocation("SaveConversation", []interface{}{arg1})
	fake.saveConversationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePersistentConversationRepository) SaveConversationCallCount() int {
	fake.saveConversationMutex.RLock()
	defer fake.saveConversationMutex.RUnlock()
	return len(fake.saveConversationArgsForCall)
}

func (fake *FakePersistentConversationRepository) SaveConversationCalls(stub func(context.Context) error) {
	fake.saveConversationMutex.Lock()
	defer fake.saveConversationMutex.Unlock()
	fake.SaveConversationStub = stub
}

func (fake *FakePersistentConversationRepository) SaveConversationArgsForCall(i int) context.Context {
	fake.saveConversationMutex.RLock()
	defer fake.saveConversationMutex.RUnlock()
	argsForCall := fake.saveConversationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePersistentConversationRepository) SaveConversationReturns(result1 error) {
	fake.saveConversationMutex.Lock()
	defer fake.saveConversationMutex.Unlock()
	fake.SaveConversationStub = nil
	fake.saveConversationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistentConversationRepository) SaveConversationReturnsOnCall(i int, result1 error) {
	fake.saveConversationMutex.Lock()
	defer fake.saveConversationMutex.Unlock()
	fake.SaveConversationStub = nil
	if fake.saveConversationReturnsOnCall == nil {
		fake.saveConversationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.saveConversationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistentConversationRepository) SetConversationTitle(arg1 string) {
	fake.setConversationTitleMutex.Lock()
	fake.setConversationTitleArgsForCall = append(fake.setConversationTitleArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.SetConversationTitleStub
	fake.recordInvocation("SetConversationTitle", []interface{}{arg1})
	fake.setConversationTitleMutex.Unlock()
	if stub != nil {
		fake.SetConversationTitleStub(arg1)
	}
}

func (fake *FakePersistentConversationRepository) SetConversationTitleCallCount() int {
	fake.setConversationTitleMutex.RLock()
	defer fake.setConversationTitleMutex.RUnlock()
	return len(fake.setConversationTitleArgsForCall)
}

func (fake *FakePersistentConversationRepository) SetConversationTitleCalls(stub func(string)) {
	fake.setConversationTitleMutex.Lock()
	defer fake.setConversationTitleMutex.Unlock()
	fake.SetConversationTitleStub = stub
}

func (fake *FakePersistentConversationRepository) SetConversationTitleArgsForCall(i int) string {
	fake.setConversationTitleMutex.RLock()
	defer fake.setConversationTitleMutex.RUnlock()
	argsForCall := fake.setConversationTitleArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePersistentConversationRepository) StartNewConversation(arg1 string) error {
	fake.startNewConversationMutex.Lock()
	ret, specificReturn := fake.startNewConversationReturnsOnCall[len(fake.startNewConversationArgsForCall)]
	fake.startNewConversationArgsForCall = append(fake.startNewConversationArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.StartNewConversationStub
	fakeReturns := fake.startNewConversationReturns
	fake.recordInvocation("StartNewConversation", []interface{}{arg1})
	fake.startNewConversationMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakePersistentConversationRepository) StartNewConversationCallCount() int {
	fake.startNewConversationMutex.RLock()
	defer fake.startNewConversationMutex.RUnlock()
	return len(fake.startNewConversationArgsForCall)
}

func (fake *FakePersistentConversationRepository) StartNewConversationCalls(stub func(string) error) {
	fake.startNewConversationMutex.Lock()
	defer fake.startNewConversationMutex.Unlock()
	fake.StartNewConversationStub = stub
}

func (fake *FakePersistentConversationRepository) StartNewConversationArgsForCall(i int) string {
	fake.startNewConversationMutex.RLock()
	defer fake.startNewConversationMutex.RUnlock()
	argsForCall := fake.startNewConversationArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakePersistentConversationRepository) StartNewConversationReturns(result1 error) {
	fake.startNewConversationMutex.Lock()
	defer fake.startNewConversationMutex.Unlock()
	fake.StartNewConversationStub = nil
	fake.startNewConversationReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistentConversationRepository) StartNewConversationReturnsOnCall(i int, result1 error) {
	fake.startNewConversationMutex.Lock()
	defer fake.startNewConversationMutex.Unlock()
	fake.StartNewConversationStub = nil
	if fake.startNewConversationReturnsOnCall == nil {
		fake.startNewConversationReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.startNewConversationReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakePersistentConversationRepository) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakePersistentConversationRepository) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ shortcuts.PersistentConversationRepository = new(FakePersistentConversationRepository)
