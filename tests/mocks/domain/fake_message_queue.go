// Code generated by counterfeiter. DO NOT EDIT.
package domain

import (
	"sync"

	"github.com/inference-gateway/cli/internal/domain"
)

type FakeMessageQueue struct {
	ClearStub        func()
	clearMutex       sync.RWMutex
	clearArgsForCall []struct {
	}
	DequeueStub        func() *domain.QueuedMessage
	dequeueMutex       sync.RWMutex
	dequeueArgsForCall []struct {
	}
	dequeueReturns struct {
		result1 *domain.QueuedMessage
	}
	dequeueReturnsOnCall map[int]struct {
		result1 *domain.QueuedMessage
	}
	EnqueueStub        func(domain.Message, string)
	enqueueMutex       sync.RWMutex
	enqueueArgsForCall []struct {
		arg1 domain.Message
		arg2 string
	}
	GetAllStub        func() []domain.QueuedMessage
	getAllMutex       sync.RWMutex
	getAllArgsForCall []struct {
	}
	getAllReturns struct {
		result1 []domain.QueuedMessage
	}
	getAllReturnsOnCall map[int]struct {
		result1 []domain.QueuedMessage
	}
	IsEmptyStub        func() bool
	isEmptyMutex       sync.RWMutex
	isEmptyArgsForCall []struct {
	}
	isEmptyReturns struct {
		result1 bool
	}
	isEmptyReturnsOnCall map[int]struct {
		result1 bool
	}
	PeekStub        func() *domain.QueuedMessage
	peekMutex       sync.RWMutex
	peekArgsForCall []struct {
	}
	peekReturns struct {
		result1 *domain.QueuedMessage
	}
	peekReturnsOnCall map[int]struct {
		result1 *domain.QueuedMessage
	}
	SizeStub        func() int
	sizeMutex       sync.RWMutex
	sizeArgsForCall []struct {
	}
	sizeReturns struct {
		result1 int
	}
	sizeReturnsOnCall map[int]struct {
		result1 int
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeMessageQueue) Clear() {
	fake.clearMutex.Lock()
	fake.clearArgsForCall = append(fake.clearArgsForCall, struct {
	}{})
	stub := fake.ClearStub
	fake.recordInvocation("Clear", []interface{}{})
	fake.clearMutex.Unlock()
	if stub != nil {
		fake.ClearStub()
	}
}

func (fake *FakeMessageQueue) ClearCallCount() int {
	fake.clearMutex.RLock()
	defer fake.clearMutex.RUnlock()
	return len(fake.clearArgsForCall)
}

func (fake *FakeMessageQueue) ClearCalls(stub func()) {
	fake.clearMutex.Lock()
	defer fake.clearMutex.Unlock()
	fake.ClearStub = stub
}

func (fake *FakeMessageQueue) Dequeue() *domain.QueuedMessage {
	fake.dequeueMutex.Lock()
	ret, specificReturn := fake.dequeueReturnsOnCall[len(fake.dequeueArgsForCall)]
	fake.dequeueArgsForCall = append(fake.dequeueArgsForCall, struct {
	}{})
	stub := fake.DequeueStub
	fakeReturns := fake.dequeueReturns
	fake.recordInvocation("Dequeue", []interface{}{})
	fake.dequeueMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessageQueue) DequeueCallCount() int {
	fake.dequeueMutex.RLock()
	defer fake.dequeueMutex.RUnlock()
	return len(fake.dequeueArgsForCall)
}

func (fake *FakeMessageQueue) DequeueCalls(stub func() *domain.QueuedMessage) {
	fake.dequeueMutex.Lock()
	defer fake.dequeueMutex.Unlock()
	fake.DequeueStub = stub
}

func (fake *FakeMessageQueue) DequeueReturns(result1 *domain.QueuedMessage) {
	fake.dequeueMutex.Lock()
	defer fake.dequeueMutex.Unlock()
	fake.DequeueStub = nil
	fake.dequeueReturns = struct {
		result1 *domain.QueuedMessage
	}{result1}
}

func (fake *FakeMessageQueue) DequeueReturnsOnCall(i int, result1 *domain.QueuedMessage) {
	fake.dequeueMutex.Lock()
	defer fake.dequeueMutex.Unlock()
	fake.DequeueStub = nil
	if fake.dequeueReturnsOnCall == nil {
		fake.dequeueReturnsOnCall = make(map[int]struct {
			result1 *domain.QueuedMessage
		})
	}
	fake.dequeueReturnsOnCall[i] = struct {
		result1 *domain.QueuedMessage
	}{result1}
}

func (fake *FakeMessageQueue) Enqueue(arg1 domain.Message, arg2 string) {
	fake.enqueueMutex.Lock()
	fake.enqueueArgsForCall = append(fake.enqueueArgsForCall, struct {
		arg1 domain.Message
		arg2 string
	}{arg1, arg2})
	stub := fake.EnqueueStub
	fake.recordInvocation("Enqueue", []interface{}{arg1, arg2})
	fake.enqueueMutex.Unlock()
	if stub != nil {
		fake.EnqueueStub(arg1, arg2)
	}
}

func (fake *FakeMessageQueue) EnqueueCallCount() int {
	fake.enqueueMutex.RLock()
	defer fake.enqueueMutex.RUnlock()
	return len(fake.enqueueArgsForCall)
}

func (fake *FakeMessageQueue) EnqueueCalls(stub func(domain.Message, string)) {
	fake.enqueueMutex.Lock()
	defer fake.enqueueMutex.Unlock()
	fake.EnqueueStub = stub
}

func (fake *FakeMessageQueue) EnqueueArgsForCall(i int) (domain.Message, string) {
	fake.enqueueMutex.RLock()
	defer fake.enqueueMutex.RUnlock()
	argsForCall := fake.enqueueArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeMessageQueue) GetAll() []domain.QueuedMessage {
	fake.getAllMutex.Lock()
	ret, specificReturn := fake.getAllReturnsOnCall[len(fake.getAllArgsForCall)]
	fake.getAllArgsForCall = append(fake.getAllArgsForCall, struct {
	}{})
	stub := fake.GetAllStub
	fakeReturns := fake.getAllReturns
	fake.recordInvocation("GetAll", []interface{}{})
	fake.getAllMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessageQueue) GetAllCallCount() int {
	fake.getAllMutex.RLock()
	defer fake.getAllMutex.RUnlock()
	return len(fake.getAllArgsForCall)
}

func (fake *FakeMessageQueue) GetAllCalls(stub func() []domain.QueuedMessage) {
	fake.getAllMutex.Lock()
	defer fake.getAllMutex.Unlock()
	fake.GetAllStub = stub
}

func (fake *FakeMessageQueue) GetAllReturns(result1 []domain.QueuedMessage) {
	fake.getAllMutex.Lock()
	defer fake.getAllMutex.Unlock()
	fake.GetAllStub = nil
	fake.getAllReturns = struct {
		result1 []domain.QueuedMessage
	}{result1}
}

func (fake *FakeMessageQueue) GetAllReturnsOnCall(i int, result1 []domain.QueuedMessage) {
	fake.getAllMutex.Lock()
	defer fake.getAllMutex.Unlock()
	fake.GetAllStub = nil
	if fake.getAllReturnsOnCall == nil {
		fake.getAllReturnsOnCall = make(map[int]struct {
			result1 []domain.QueuedMessage
		})
	}
	fake.getAllReturnsOnCall[i] = struct {
		result1 []domain.QueuedMessage
	}{result1}
}

func (fake *FakeMessageQueue) IsEmpty() bool {
	fake.isEmptyMutex.Lock()
	ret, specificReturn := fake.isEmptyReturnsOnCall[len(fake.isEmptyArgsForCall)]
	fake.isEmptyArgsForCall = append(fake.isEmptyArgsForCall, struct {
	}{})
	stub := fake.IsEmptyStub
	fakeReturns := fake.isEmptyReturns
	fake.recordInvocation("IsEmpty", []interface{}{})
	fake.isEmptyMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessageQueue) IsEmptyCallCount() int {
	fake.isEmptyMutex.RLock()
	defer fake.isEmptyMutex.RUnlock()
	return len(fake.isEmptyArgsForCall)
}

func (fake *FakeMessageQueue) IsEmptyCalls(stub func() bool) {
	fake.isEmptyMutex.Lock()
	defer fake.isEmptyMutex.Unlock()
	fake.IsEmptyStub = stub
}

func (fake *FakeMessageQueue) IsEmptyReturns(result1 bool) {
	fake.isEmptyMutex.Lock()
	defer fake.isEmptyMutex.Unlock()
	fake.IsEmptyStub = nil
	fake.isEmptyReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeMessageQueue) IsEmptyReturnsOnCall(i int, result1 bool) {
	fake.isEmptyMutex.Lock()
	defer fake.isEmptyMutex.Unlock()
	fake.IsEmptyStub = nil
	if fake.isEmptyReturnsOnCall == nil {
		fake.isEmptyReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isEmptyReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeMessageQueue) Peek() *domain.QueuedMessage {
	fake.peekMutex.Lock()
	ret, specificReturn := fake.peekReturnsOnCall[len(fake.peekArgsForCall)]
	fake.peekArgsForCall = append(fake.peekArgsForCall, struct {
	}{})
	stub := fake.PeekStub
	fakeReturns := fake.peekReturns
	fake.recordInvocation("Peek", []interface{}{})
	fake.peekMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessageQueue) PeekCallCount() int {
	fake.peekMutex.RLock()
	defer fake.peekMutex.RUnlock()
	return len(fake.peekArgsForCall)
}

func (fake *FakeMessageQueue) PeekCalls(stub func() *domain.QueuedMessage) {
	fake.peekMutex.Lock()
	defer fake.peekMutex.Unlock()
	fake.PeekStub = stub
}

func (fake *FakeMessageQueue) PeekReturns(result1 *domain.QueuedMessage) {
	fake.peekMutex.Lock()
	defer fake.peekMutex.Unlock()
	fake.PeekStub = nil
	fake.peekReturns = struct {
		result1 *domain.QueuedMessage
	}{result1}
}

func (fake *FakeMessageQueue) PeekReturnsOnCall(i int, result1 *domain.QueuedMessage) {
	fake.peekMutex.Lock()
	defer fake.peekMutex.Unlock()
	fake.PeekStub = nil
	if fake.peekReturnsOnCall == nil {
		fake.peekReturnsOnCall = make(map[int]struct {
			result1 *domain.QueuedMessage
		})
	}
	fake.peekReturnsOnCall[i] = struct {
		result1 *domain.QueuedMessage
	}{result1}
}

func (fake *FakeMessageQueue) Size() int {
	fake.sizeMutex.Lock()
	ret, specificReturn := fake.sizeReturnsOnCall[len(fake.sizeArgsForCall)]
	fake.sizeArgsForCall = append(fake.sizeArgsForCall, struct {
	}{})
	stub := fake.SizeStub
	fakeReturns := fake.sizeReturns
	fake.recordInvocation("Size", []interface{}{})
	fake.sizeMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeMessageQueue) SizeCallCount() int {
	fake.sizeMutex.RLock()
	defer fake.sizeMutex.RUnlock()
	return len(fake.sizeArgsForCall)
}

func (fake *FakeMessageQueue) SizeCalls(stub func() int) {
	fake.sizeMutex.Lock()
	defer fake.sizeMutex.Unlock()
	fake.SizeStub = stub
}

func (fake *FakeMessageQueue) SizeReturns(result1 int) {
	fake.sizeMutex.Lock()
	defer fake.sizeMutex.Unlock()
	fake.SizeStub = nil
	fake.sizeReturns = struct {
		result1 int
	}{result1}
}

func (fake *FakeMessageQueue) SizeReturnsOnCall(i int, result1 int) {
	fake.sizeMutex.Lock()
	defer fake.sizeMutex.Unlock()
	fake.SizeStub = nil
	if fake.sizeReturnsOnCall == nil {
		fake.sizeReturnsOnCall = make(map[int]struct {
			result1 int
		})
	}
	fake.sizeReturnsOnCall[i] = struct {
		result1 int
	}{result1}
}

func (fake *FakeMessageQueue) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeMessageQueue) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ domain.MessageQueue = new(FakeMessageQueue)
