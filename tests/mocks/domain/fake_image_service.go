// Code generated by counterfeiter. DO NOT EDIT.
package domain

import (
	"sync"

	"github.com/inference-gateway/cli/internal/domain"
)

type FakeImageService struct {
	CreateDataURLStub        func(*domain.ImageAttachment) string
	createDataURLMutex       sync.RWMutex
	createDataURLArgsForCall []struct {
		arg1 *domain.ImageAttachment
	}
	createDataURLReturns struct {
		result1 string
	}
	createDataURLReturnsOnCall map[int]struct {
		result1 string
	}
	IsImageFileStub        func(string) bool
	isImageFileMutex       sync.RWMutex
	isImageFileArgsForCall []struct {
		arg1 string
	}
	isImageFileReturns struct {
		result1 bool
	}
	isImageFileReturnsOnCall map[int]struct {
		result1 bool
	}
	IsImageURLStub        func(string) bool
	isImageURLMutex       sync.RWMutex
	isImageURLArgsForCall []struct {
		arg1 string
	}
	isImageURLReturns struct {
		result1 bool
	}
	isImageURLReturnsOnCall map[int]struct {
		result1 bool
	}
	ReadImageFromBinaryStub        func([]byte, string) (*domain.ImageAttachment, error)
	readImageFromBinaryMutex       sync.RWMutex
	readImageFromBinaryArgsForCall []struct {
		arg1 []byte
		arg2 string
	}
	readImageFromBinaryReturns struct {
		result1 *domain.ImageAttachment
		result2 error
	}
	readImageFromBinaryReturnsOnCall map[int]struct {
		result1 *domain.ImageAttachment
		result2 error
	}
	ReadImageFromFileStub        func(string) (*domain.ImageAttachment, error)
	readImageFromFileMutex       sync.RWMutex
	readImageFromFileArgsForCall []struct {
		arg1 string
	}
	readImageFromFileReturns struct {
		result1 *domain.ImageAttachment
		result2 error
	}
	readImageFromFileReturnsOnCall map[int]struct {
		result1 *domain.ImageAttachment
		result2 error
	}
	ReadImageFromURLStub        func(string) (*domain.ImageAttachment, error)
	readImageFromURLMutex       sync.RWMutex
	readImageFromURLArgsForCall []struct {
		arg1 string
	}
	readImageFromURLReturns struct {
		result1 *domain.ImageAttachment
		result2 error
	}
	readImageFromURLReturnsOnCall map[int]struct {
		result1 *domain.ImageAttachment
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeImageService) CreateDataURL(arg1 *domain.ImageAttachment) string {
	fake.createDataURLMutex.Lock()
	ret, specificReturn := fake.createDataURLReturnsOnCall[len(fake.createDataURLArgsForCall)]
	fake.createDataURLArgsForCall = append(fake.createDataURLArgsForCall, struct {
		arg1 *domain.ImageAttachment
	}{arg1})
	stub := fake.CreateDataURLStub
	fakeReturns := fake.createDataURLReturns
	fake.recordInvocation("CreateDataURL", []interface{}{arg1})
	fake.createDataURLMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImageService) CreateDataURLCallCount() int {
	fake.createDataURLMutex.RLock()
	defer fake.createDataURLMutex.RUnlock()
	return len(fake.createDataURLArgsForCall)
}

func (fake *FakeImageService) CreateDataURLCalls(stub func(*domain.ImageAttachment) string) {
	fake.createDataURLMutex.Lock()
	defer fake.createDataURLMutex.Unlock()
	fake.CreateDataURLStub = stub
}

func (fake *FakeImageService) CreateDataURLArgsForCall(i int) *domain.ImageAttachment {
	fake.createDataURLMutex.RLock()
	defer fake.createDataURLMutex.RUnlock()
	argsForCall := fake.createDataURLArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImageService) CreateDataURLReturns(result1 string) {
	fake.createDataURLMutex.Lock()
	defer fake.createDataURLMutex.Unlock()
	fake.CreateDataURLStub = nil
	fake.createDataURLReturns = struct {
		result1 string
	}{result1}
}

func (fake *FakeImageService) CreateDataURLReturnsOnCall(i int, result1 string) {
	fake.createDataURLMutex.Lock()
	defer fake.createDataURLMutex.Unlock()
	fake.CreateDataURLStub = nil
	if fake.createDataURLReturnsOnCall == nil {
		fake.createDataURLReturnsOnCall = make(map[int]struct {
			result1 string
		})
	}
	fake.createDataURLReturnsOnCall[i] = struct {
		result1 string
	}{result1}
}

func (fake *FakeImageService) IsImageFile(arg1 string) bool {
	fake.isImageFileMutex.Lock()
	ret, specificReturn := fake.isImageFileReturnsOnCall[len(fake.isImageFileArgsForCall)]
	fake.isImageFileArgsForCall = append(fake.isImageFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsImageFileStub
	fakeReturns := fake.isImageFileReturns
	fake.recordInvocation("IsImageFile", []interface{}{arg1})
	fake.isImageFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImageService) IsImageFileCallCount() int {
	fake.isImageFileMutex.RLock()
	defer fake.isImageFileMutex.RUnlock()
	return len(fake.isImageFileArgsForCall)
}

func (fake *FakeImageService) IsImageFileCalls(stub func(string) bool) {
	fake.isImageFileMutex.Lock()
	defer fake.isImageFileMutex.Unlock()
	fake.IsImageFileStub = stub
}

func (fake *FakeImageService) IsImageFileArgsForCall(i int) string {
	fake.isImageFileMutex.RLock()
	defer fake.isImageFileMutex.RUnlock()
	argsForCall := fake.isImageFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImageService) IsImageFileReturns(result1 bool) {
	fake.isImageFileMutex.Lock()
	defer fake.isImageFileMutex.Unlock()
	fake.IsImageFileStub = nil
	fake.isImageFileReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeImageService) IsImageFileReturnsOnCall(i int, result1 bool) {
	fake.isImageFileMutex.Lock()
	defer fake.isImageFileMutex.Unlock()
	fake.IsImageFileStub = nil
	if fake.isImageFileReturnsOnCall == nil {
		fake.isImageFileReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isImageFileReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeImageService) IsImageURL(arg1 string) bool {
	fake.isImageURLMutex.Lock()
	ret, specificReturn := fake.isImageURLReturnsOnCall[len(fake.isImageURLArgsForCall)]
	fake.isImageURLArgsForCall = append(fake.isImageURLArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.IsImageURLStub
	fakeReturns := fake.isImageURLReturns
	fake.recordInvocation("IsImageURL", []interface{}{arg1})
	fake.isImageURLMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeImageService) IsImageURLCallCount() int {
	fake.isImageURLMutex.RLock()
	defer fake.isImageURLMutex.RUnlock()
	return len(fake.isImageURLArgsForCall)
}

func (fake *FakeImageService) IsImageURLCalls(stub func(string) bool) {
	fake.isImageURLMutex.Lock()
	defer fake.isImageURLMutex.Unlock()
	fake.IsImageURLStub = stub
}

func (fake *FakeImageService) IsImageURLArgsForCall(i int) string {
	fake.isImageURLMutex.RLock()
	defer fake.isImageURLMutex.RUnlock()
	argsForCall := fake.isImageURLArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImageService) IsImageURLReturns(result1 bool) {
	fake.isImageURLMutex.Lock()
	defer fake.isImageURLMutex.Unlock()
	fake.IsImageURLStub = nil
	fake.isImageURLReturns = struct {
		result1 bool
	}{result1}
}

func (fake *FakeImageService) IsImageURLReturnsOnCall(i int, result1 bool) {
	fake.isImageURLMutex.Lock()
	defer fake.isImageURLMutex.Unlock()
	fake.IsImageURLStub = nil
	if fake.isImageURLReturnsOnCall == nil {
		fake.isImageURLReturnsOnCall = make(map[int]struct {
			result1 bool
		})
	}
	fake.isImageURLReturnsOnCall[i] = struct {
		result1 bool
	}{result1}
}

func (fake *FakeImageService) ReadImageFromBinary(arg1 []byte, arg2 string) (*domain.ImageAttachment, error) {
	var arg1Copy []byte
	if arg1 != nil {
		arg1Copy = make([]byte, len(arg1))
		copy(arg1Copy, arg1)
	}
	fake.readImageFromBinaryMutex.Lock()
	ret, specificReturn := fake.readImageFromBinaryReturnsOnCall[len(fake.readImageFromBinaryArgsForCall)]
	fake.readImageFromBinaryArgsForCall = append(fake.readImageFromBinaryArgsForCall, struct {
		arg1 []byte
		arg2 string
	}{arg1Copy, arg2})
	stub := fake.ReadImageFromBinaryStub
	fakeReturns := fake.readImageFromBinaryReturns
	fake.recordInvocation("ReadImageFromBinary", []interface{}{arg1Copy, arg2})
	fake.readImageFromBinaryMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImageService) ReadImageFromBinaryCallCount() int {
	fake.readImageFromBinaryMutex.RLock()
	defer fake.readImageFromBinaryMutex.RUnlock()
	return len(fake.readImageFromBinaryArgsForCall)
}

func (fake *FakeImageService) ReadImageFromBinaryCalls(stub func([]byte, string) (*domain.ImageAttachment, error)) {
	fake.readImageFromBinaryMutex.Lock()
	defer fake.readImageFromBinaryMutex.Unlock()
	fake.ReadImageFromBinaryStub = stub
}

func (fake *FakeImageService) ReadImageFromBinaryArgsForCall(i int) ([]byte, string) {
	fake.readImageFromBinaryMutex.RLock()
	defer fake.readImageFromBinaryMutex.RUnlock()
	argsForCall := fake.readImageFromBinaryArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeImageService) ReadImageFromBinaryReturns(result1 *domain.ImageAttachment, result2 error) {
	fake.readImageFromBinaryMutex.Lock()
	defer fake.readImageFromBinaryMutex.Unlock()
	fake.ReadImageFromBinaryStub = nil
	fake.readImageFromBinaryReturns = struct {
		result1 *domain.ImageAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeImageService) ReadImageFromBinaryReturnsOnCall(i int, result1 *domain.ImageAttachment, result2 error) {
	fake.readImageFromBinaryMutex.Lock()
	defer fake.readImageFromBinaryMutex.Unlock()
	fake.ReadImageFromBinaryStub = nil
	if fake.readImageFromBinaryReturnsOnCall == nil {
		fake.readImageFromBinaryReturnsOnCall = make(map[int]struct {
			result1 *domain.ImageAttachment
			result2 error
		})
	}
	fake.readImageFromBinaryReturnsOnCall[i] = struct {
		result1 *domain.ImageAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeImageService) ReadImageFromFile(arg1 string) (*domain.ImageAttachment, error) {
	fake.readImageFromFileMutex.Lock()
	ret, specificReturn := fake.readImageFromFileReturnsOnCall[len(fake.readImageFromFileArgsForCall)]
	fake.readImageFromFileArgsForCall = append(fake.readImageFromFileArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadImageFromFileStub
	fakeReturns := fake.readImageFromFileReturns
	fake.recordInvocation("ReadImageFromFile", []interface{}{arg1})
	fake.readImageFromFileMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImageService) ReadImageFromFileCallCount() int {
	fake.readImageFromFileMutex.RLock()
	defer fake.readImageFromFileMutex.RUnlock()
	return len(fake.readImageFromFileArgsForCall)
}

func (fake *FakeImageService) ReadImageFromFileCalls(stub func(string) (*domain.ImageAttachment, error)) {
	fake.readImageFromFileMutex.Lock()
	defer fake.readImageFromFileMutex.Unlock()
	fake.ReadImageFromFileStub = stub
}

func (fake *FakeImageService) ReadImageFromFileArgsForCall(i int) string {
	fake.readImageFromFileMutex.RLock()
	defer fake.readImageFromFileMutex.RUnlock()
	argsForCall := fake.readImageFromFileArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImageService) ReadImageFromFileReturns(result1 *domain.ImageAttachment, result2 error) {
	fake.readImageFromFileMutex.Lock()
	defer fake.readImageFromFileMutex.Unlock()
	fake.ReadImageFromFileStub = nil
	fake.readImageFromFileReturns = struct {
		result1 *domain.ImageAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeImageService) ReadImageFromFileReturnsOnCall(i int, result1 *domain.ImageAttachment, result2 error) {
	fake.readImageFromFileMutex.Lock()
	defer fake.readImageFromFileMutex.Unlock()
	fake.ReadImageFromFileStub = nil
	if fake.readImageFromFileReturnsOnCall == nil {
		fake.readImageFromFileReturnsOnCall = make(map[int]struct {
			result1 *domain.ImageAttachment
			result2 error
		})
	}
	fake.readImageFromFileReturnsOnCall[i] = struct {
		result1 *domain.ImageAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeImageService) ReadImageFromURL(arg1 string) (*domain.ImageAttachment, error) {
	fake.readImageFromURLMutex.Lock()
	ret, specificReturn := fake.readImageFromURLReturnsOnCall[len(fake.readImageFromURLArgsForCall)]
	fake.readImageFromURLArgsForCall = append(fake.readImageFromURLArgsForCall, struct {
		arg1 string
	}{arg1})
	stub := fake.ReadImageFromURLStub
	fakeReturns := fake.readImageFromURLReturns
	fake.recordInvocation("ReadImageFromURL", []interface{}{arg1})
	fake.readImageFromURLMutex.Unlock()
	if stub != nil {
		return stub(arg1)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeImageService) ReadImageFromURLCallCount() int {
	fake.readImageFromURLMutex.RLock()
	defer fake.readImageFromURLMutex.RUnlock()
	return len(fake.readImageFromURLArgsForCall)
}

func (fake *FakeImageService) ReadImageFromURLCalls(stub func(string) (*domain.ImageAttachment, error)) {
	fake.readImageFromURLMutex.Lock()
	defer fake.readImageFromURLMutex.Unlock()
	fake.ReadImageFromURLStub = stub
}

func (fake *FakeImageService) ReadImageFromURLArgsForCall(i int) string {
	fake.readImageFromURLMutex.RLock()
	defer fake.readImageFromURLMutex.RUnlock()
	argsForCall := fake.readImageFromURLArgsForCall[i]
	return argsForCall.arg1
}

func (fake *FakeImageService) ReadImageFromURLReturns(result1 *domain.ImageAttachment, result2 error) {
	fake.readImageFromURLMutex.Lock()
	defer fake.readImageFromURLMutex.Unlock()
	fake.ReadImageFromURLStub = nil
	fake.readImageFromURLReturns = struct {
		result1 *domain.ImageAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeImageService) ReadImageFromURLReturnsOnCall(i int, result1 *domain.ImageAttachment, result2 error) {
	fake.readImageFromURLMutex.Lock()
	defer fake.readImageFromURLMutex.Unlock()
	fake.ReadImageFromURLStub = nil
	if fake.readImageFromURLReturnsOnCall == nil {
		fake.readImageFromURLReturnsOnCall = make(map[int]struct {
			result1 *domain.ImageAttachment
			result2 error
		})
	}
	fake.readImageFromURLReturnsOnCall[i] = struct {
		result1 *domain.ImageAttachment
		result2 error
	}{result1, result2}
}

func (fake *FakeImageService) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeImageService) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ domain.ImageService = new(FakeImageService)
